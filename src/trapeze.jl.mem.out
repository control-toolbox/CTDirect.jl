        - #= Functions for trapeze discretization scheme
        - Internal layout for NLP variables: 
        - [X_0,U_0, X_1,U_1, .., X_N,U_N, V]
        - =#
        - 
        - # NB. could be defined as a generic IRK
        - struct Trapeze <: Discretization
        - 
        -     stage::Int
        -     additional_controls::Int  # add control at tf
        -     info::String
        - 
        -     Trapeze() = new(0, 1, "Implicit Trapeze aka Crank-Nicolson, 2nd order, A-stable")
        - end
        - 
        - 
        - """
        - $(TYPEDSIGNATURES)
        - 
        - Retrieve state and control variables at given time step from the NLP variables.
        - Convention: 1 <= i <= dim_NLP_steps+1
        - """
        - function get_variables_at_time_step(xu, docp::DOCP{Trapeze}, i)
        - 
        0     nx = docp.dim_NLP_x
        0     n = docp.dim_OCP_x
        0     m = docp.dim_NLP_u
        0     offset = (nx + m) * (i-1)
        - 
        -     # retrieve scalar/vector OCP state (w/o lagrange state) 
        0     if n == 1
        0         xi = xu[offset + 1]
        -     else
        0         xi = xu[(offset + 1):(offset + n)]
        -     end
        0     if docp.has_lagrange
        0         xli = xu[offset + nx]
        -     else
        -         xli = nothing # dummy. use xu type ?
        -     end
        - 
        -     # retrieve scalar/vector control
        0     if m == 1
        0         ui = xu[offset + nx + 1]
        -     else
        0         ui = xu[(offset + nx + 1):(offset + nx + m)]
        -     end
        - 
        0     return xi, ui, xli
        - end
        - 
        - 
        - # internal NLP version for solution parsing
        - # could be fused with one above if 
        - # - using extended dynamics that include lagrange cost
        - # - scalar case is handled at OCP level
        - function get_NLP_variables_at_t_i(xu, docp::DOCP{Trapeze}, i::Int)
        - 
        -     nx = docp.dim_NLP_x
        -     m = docp.dim_NLP_u
        -     offset = (nx + m) * i
        - 
        -     # state
        -     xi = xu[(offset + 1):(offset + nx)]
        -     # control
        -     ui = xu[(offset + nx + 1):(offset + nx + m)]
        - 
        -     return xi, ui
        - end
        - 
        - 
        - function set_variables_at_t_i!(xu, x_init, u_init, docp::DOCP{Trapeze}, i::Int)
        - 
        0     nx = docp.dim_NLP_x
        0     n = docp.dim_OCP_x
        0     m = docp.dim_NLP_u
        -     N = docp.dim_NLP_steps
        0     offset = (nx + m) * i
        - 
        -     # NB. only set the actual state variables from the OCP 
        -     # - skip the possible additional state for lagrange cost
        0     if !isnothing(x_init)
        0         xu[(offset + 1):(offset + n)] .= x_init
        -     end
        -     if !isnothing(u_init)
        0         xu[(offset + nx + 1):(offset + nx + m)] .= u_init
        -     end
        - end
        - 
        - 
        - # can later contain vectors for inplace getters ?
        - # for trapeze the dynamics (init at t0, compute and store at i+1)
        - function setWorkArray(docp::DOCP{Trapeze}, xu, time_grid, v)
        -    
       80     work = similar(xu, docp.dim_NLP_x)
        - 
        -     ocp = docp.ocp
        0     t0 = time_grid[1]
       80     x0, u0 = get_variables_at_time_step(xu, docp, 1)
        -     
        0     if docp.has_inplace
        0         docp.dynamics((@view work[1:docp.dim_OCP_x]), t0, x0, u0, v)
        -     else
      144         work[1:docp.dim_OCP_x] .= docp.dynamics(t0, x0, u0, v)
        -     end
        -     
        0     if docp.has_lagrange
        0         if docp.has_inplace
        0             l = similar(xu, 1)
        0             docp.lagrange(l, t0, x0, u0, v) # +++cannot pass work[end] directly ?
        0             work[docp.dim_NLP_x] = l[1]
        -         else
        0             work[docp.dim_NLP_x] = docp.lagrange(t0, x0, u0, v)
        -         end
        -     end
        - 
        0     return work
        - end
        - 
        - 
        - """
        - $(TYPEDSIGNATURES)
        - 
        - Set the constraints corresponding to the state equation
        - Convention: 1 <= i <= dim_NLP_steps
        - """
        - function setConstraintBlock!(docp::DOCP{Trapeze}, c, xu, v, time_grid, i, work)
        - 
        -     # offset for previous steps
        0     offset = (i-1)*(docp.dim_NLP_x + docp.dim_path_cons)
        - 
        -     # variables
        -     ocp = docp.ocp
        0     ti = time_grid[i]
      800     xi, ui, xli = get_variables_at_time_step(xu, docp, i)
      800     fi = work[1:docp.dim_OCP_x] # copy !
        - 
        0     tip1 = time_grid[i+1]
      800     xip1, uip1, xlip1 = get_variables_at_time_step(xu, docp, i+1)
        0     if docp.has_inplace
        0         docp.dynamics((@view work[1:docp.dim_OCP_x]), tip1, xip1, uip1, v)
        -     else
     1440         work[1:docp.dim_OCP_x] .= docp.dynamics(tip1, xip1, uip1, v)
        -     end
      160     hi = tip1 - ti
        - 
        -     # trapeze rule with 'smart' update for dynamics
     3200     @. c[offset+1:offset+docp.dim_OCP_x] = xip1 - (xi + 0.5 * hi * (fi + work[1:docp.dim_OCP_x]))
        -     
        0     if docp.has_lagrange
        0         li = work[docp.dim_OCP_x+1]
        0         if docp.has_inplace
        0             lip1 = similar(xu, 1)
        0             docp.lagrange(lip1, tip1, xip1, uip1, v) # +++cannot pass work[end] directly ?
        0             work[docp.dim_OCP_x+1] = lip1[1]
        -         else
        0             work[docp.dim_OCP_x+1] = docp.lagrange(tip1, xip1, uip1, v)
        -         end
        0         c[offset+docp.dim_OCP_x+1] = xlip1 - (xli + 0.5 * hi * (li + work[docp.dim_OCP_x+1]))
        -     end
        0     offset += docp.dim_NLP_x    
        - 
        -     # path constraints
     3312     setPathConstraints!(docp, c, ti, xi, ui, v, offset)
        - 
        - end
