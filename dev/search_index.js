var documenterSearchIndex = {"docs":
[{"location":"solve-options.html#solve-options","page":"solve options","title":"solve options","text":"","category":"section"},{"location":"solve-options.html","page":"solve options","title":"solve options","text":"See solve method.","category":"page"},{"location":"api.html#CTDirect-API","page":"API","title":"CTDirect API","text":"","category":"section"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#Available-methods","page":"API","title":"Available methods","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"using CTDirect\navailable_methods()","category":"page"},{"location":"api.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#CTDirect.OptimalControlInit","page":"API","title":"CTDirect.OptimalControlInit","text":"Initialization of the optimal control problem solution for the NLP problem.\n\nConstructors:\n\nOptimalControlInit(): default initialization\nOptimalControlInit(x_init, u_init, v_init): constant vector or function handles\nOptimalControlInit(sol): from existing solution\n\nExamples\n\njulia> init = OptimalControlInit()\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3, v_init=0.5)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=t->sin(t), v_init=0.5)\njulia> init = OptimalControlInit(sol)\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTDirect.available_methods-Tuple{}","page":"API","title":"CTDirect.available_methods","text":"available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTDirect.is_solvable-Tuple{Any}","page":"API","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nReturn if the optimal control problem ocp is solvable or not by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTDirect.solve-Tuple{OptimalControlModel, Vararg{Any}}","page":"API","title":"CTDirect.solve","text":"solve(\n    ocp::OptimalControlModel,\n    description...;\n    display,\n    init,\n    grid_size,\n    print_level,\n    mu_strategy,\n    kwargs...\n) -> OptimalControlSolution\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description. Return an  OptimalControlSolution from CTBase package, that is an approximation of  the optimal solution if the method has converged correctly.\n\nThe (optional) description\n\nYou can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list, the higher is the priority.\n\nKeyword arguments:\n\ndisplay: print or not information during the resolution\ninit: an initial condition for the solver\ngrid_size: number of time steps for the discretization\nprint_level: print level for the Ipopt solver\nmu_strategy: mu strategy for the Ipopt solver\n\nwarning: Warning\nThere is only one available method for the moment: the direct method transforms the optimal control problem into a nonlinear programming problem (NLP) solved by Ipopt, thanks to the package  ADNLPModels.\n\ntip: Tip\nTo see the list of available methods, simply call available_methods().\nYou can pass any other option by a pair keyword=value according to the chosen method. See for instance, Ipopt options.\nThe default values for the keyword arguments are given here.\n\njulia> solve(ocp)\njulia> solve(ocp, :adnlp)\njulia> solve(ocp, :adnlp, :ipopt)\njulia> solve(ocp, display=false, init=OptimalControlInit(), grid_size=100, print_level=0, mu_strategy=\"adaptive\")\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#Internal-functions","page":"Internal functions","title":"Internal functions","text":"","category":"section"},{"location":"dev-api.html","page":"Internal functions","title":"Internal functions","text":"CurrentModule = CTDirect ","category":"page"},{"location":"dev-api.html","page":"Internal functions","title":"Internal functions","text":"Modules = [CTDirect]\nOrder = [:module, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"optimization.html#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"optimization.html","page":"Optimization","title":"Optimization","text":"For the moment we have implemented only Ipopt for the optimization soltware","category":"page"},{"location":"index.html#CTDirect.jl","page":"Introduction","title":"CTDirect.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  CTDirect","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"<img src=\"./assets/diagram.png\" style=\"display: block; margin: 0 auto 20px auto;\" width=\"320px\">","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install\nTo install a package from the control-toolbox ecosystem,  please visit the installation page.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An optimal control problem with fixed initial and final times, denoted (OCP), can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The so-called direct approach transforms the infinite dimensional optimal control problem (OCP) into a finite dimensional optimization problem (NLP). This is done by a discretization in time by Runge-Kutta methods applied to the state and control variables, as well as the dynamics equation. These methods are usually less precise than indirect methods based on Pontryagin’s Maximum Principle, but more robust with respect to the initialization. Also, they are more straightforward to apply, hence their wide use in industrial applications. We refer the reader to for instance[1] and [2] for more details on direct transcription methods and NLP algorithms.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1]: J. T. Betts. Practical methods for optimal control using nonlinear programming. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2001.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[2]: J. Nocedal and S.J. Wright. Numerical optimization. Springer-Verlag, New York, 1999.****","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Example of the time discretization by the trapezoidal rule:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarraylcl\nt in t_0t_f    to  t_0 ldots t_N=t_f02em\nx(cdot) u(cdot)  to  X=x_0 ldots x_N u_0 ldots u_N 1em\nhline\n\ntextstep  to  h = (t_f-t_0)N02em\ntextcriterion  to  min g(x_0 x_N) 02em\ntextdynamics   to  x_i+i = x_i + (h2) (f(t_i x_i u_i) + f(t_i+1 x_i+1 u_i+1)) 02em\ntextcontrol constraints to xi_l  le  xi(t_i u_i)   le xi_u 02em\ntextpath constraints to eta_l le eta(t_i x_i)        le eta_u 02em\ntextmixed constraints to psi_l le psi(t_i x_i u_i) le psi_u 02em\ntextlimit conditions to phi_l le phi(x_0 x_N) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We therefore obtain a nonlinear programming problem on the discretized state and control variables of the general form:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(NLP)quad left\nbeginarraylr\nmin  F(X) \nLB le C(X) le UB\nendarray\nright","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We use packages from JuliaSmoothOptimizers to solve the (NLP) problem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"As input of this package we use an OptimalControlModel structure from CTBase.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Current limitations\nFor the moment we have only implementedtrapezoidal rule for the discretization\nIpopt for the optimization software","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Related packages\nThis package is equivalent to the bocop software.","category":"page"},{"location":"api-ctbase.html#CTBase-API","page":"CTBase API","title":"CTBase API","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"This is just a dump of CTBase API documentation. For more details about CTBase.jl package, see the documentation.","category":"page"},{"location":"api-ctbase.html#Index","page":"CTBase API","title":"Index","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Pages   = [\"api-ctbase.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#Documentation","page":"CTBase API","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase API","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataStructures\nDocStringExtensions\nLinearAlgebra\nMLStyle\nParameters\nPlots\nPrettyTables\nPrintf\nReplMaker\nUnicode\n\nList of all the exported names:\n\nAbstractHamiltonian\nAmbiguousDescription\nAutonomous\nBoundaryConstraint\nCTCallback\nCTCallbacks\nCTException\nControl\nControlConstraint\nControlLaw\nControls\nCostate\nCostates\nDCostate\nDState\nDescription\nDimension\nDynamics\nFeedbackControl\nFixed\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrange\n@Lie\nLie\nLift\nMayer\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nNotImplemented\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nPrintCallback\nState\nStateConstraint\nStates\nStopCallback\nTime\nTimeDependence\nTimes\nTimesDisc\nUnauthorizedCall\nVariable\nVariableConstraint\nVariableDependence\nVectorField\nadd\nconstraint\nconstraint!\nconstraint_type\nconstraints_labels\ncontrol!\nctNumber\nctVector\nct_repl\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\n@def\ndynamics!\ngetFullDescription\nget_priority_print_callbacks\nget_priority_stop_callbacks\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nnlp_constraints\nobjective!\nplot\nplot!\nremove_constraint!\nreplace_call\nstate!\ntime!\nvariable!\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html#CTBase.Control","page":"CTBase API","title":"CTBase.Control","text":"Type alias for a control.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costate","page":"CTBase API","title":"CTBase.Costate","text":"Type alias for an costate.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DCostate","page":"CTBase API","title":"CTBase.DCostate","text":"Type alias for a tangent vector to the costate space.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DState","page":"CTBase API","title":"CTBase.DState","text":"Type alias for a tangent vector to the state space.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.State","page":"CTBase API","title":"CTBase.State","text":"Type alias for a state.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimesDisc","page":"CTBase API","title":"CTBase.TimesDisc","text":"Type alias for a grid of times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Variable","page":"CTBase API","title":"CTBase.Variable","text":"Type alias for a variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ctVector","page":"CTBase API","title":"CTBase.ctVector","text":"Type alias for a vector of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AbstractHamiltonian","page":"CTBase API","title":"CTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian{time_dependence, variable_dependence}\n\nAbstract type for hamiltonians.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AmbiguousDescription","page":"CTBase API","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Autonomous","page":"CTBase API","title":"CTBase.Autonomous","text":"abstract type Autonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"struct BoundaryConstraint{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor BoundaryConstraint returns a BoundaryConstraint of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar. When the constraint is dimension 1, return a scalar.\n\nCall\n\nThe call returns the evaluation of the BoundaryConstraint for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...;\n    variable\n) -> BoundaryConstraint\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a DataType: NonFixed/Fixed or with a boolean, variable, false by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2], Fixed)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"Return the evaluation of the BoundaryConstraint at x0, xf, v.\n\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"Return the evaluation of the BoundaryConstraint at x0, xf.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.CTCallback","page":"CTBase API","title":"CTBase.CTCallback","text":"abstract type CTCallback\n\nAbstract type for callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.CTCallbacks","page":"CTBase API","title":"CTBase.CTCallbacks","text":"Tuple of callbacks\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.CTException","page":"CTBase API","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint","page":"CTBase API","title":"CTBase.ControlConstraint","text":"struct ControlConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlConstraint returns a ControlConstraint of a function. The function must take 1 to 3 arguments, u to (t, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the control is of dimension 1, consider u as a scalar.\n\nCall\n\nThe call returns the evaluation of the ControlConstraint for given values.\n\nExamples\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the ControlConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"Return the value of the ControlConstraint function.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw","page":"CTBase API","title":"CTBase.ControlLaw","text":"struct ControlLaw{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Hamiltonian in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlLaw returns a ControlLaw of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the ControlLaw for given values.\n\nExamples\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"Return the value of the ControlLaw function.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Controls","page":"CTBase API","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costates","page":"CTBase API","title":"CTBase.Costates","text":"Type alias for a vector of costates.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Description","page":"CTBase API","title":"CTBase.Description","text":"A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dimension","page":"CTBase API","title":"CTBase.Dimension","text":"Type alias for a dimension.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics","page":"CTBase API","title":"CTBase.Dynamics","text":"struct Dynamics{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Dynamics returns a Dynamics of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Dynamics for given values.\n\nExamples\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Return the value of the Dynamics function.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl","page":"CTBase API","title":"CTBase.FeedbackControl","text":"struct FeedbackControl{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor FeedbackControl returns a FeedbackControl of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the FeedbackControl for given values.\n\nExamples\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"Return the value of the FeedbackControl function.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Fixed","page":"CTBase API","title":"CTBase.Fixed","text":"abstract type Fixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian","page":"CTBase API","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Hamiltonian returns a Hamiltonian of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Hamiltonian for given values.\n\nExamples\n\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Return the value of the Hamiltonian.\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nLifts\n\nX::VectorField\n\nThe values for time_dependence and variable_dependence are deternimed by the values of those for the VectorField.\n\nConstructor\n\nThe constructor HamiltonianLift returns a HamiltonianLift of a VectorField.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed))\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianLift for given values.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\nAlternatively, it is possible to construct the HamiltonianLift from a Function being the VectorField.\n\njulia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"Return the value of the HamiltonianLift.\n\nExamples\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor HamiltonianVectorField returns a HamiltonianVectorField of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianVectorField for given values.\n\nExamples\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"Return the value of the HamiltonianVectorField.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.IncorrectArgument","page":"CTBase API","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectMethod","page":"CTBase API","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectOutput","page":"CTBase API","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Index","page":"CTBase API","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange","page":"CTBase API","title":"CTBase.Lagrange","text":"struct Lagrange{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Lagrange returns a Lagrange cost of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Lagrange cost for given values.\n\nExamples\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Return the value of the Lagrange function.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer","page":"CTBase API","title":"CTBase.Mayer","text":"struct Mayer{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor Mayer returns a Mayer cost of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar.\n\nCall\n\nThe call returns the evaluation of the Mayer cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Mayer","text":"Mayer(\n    f::Function,\n    dependencies::DataType...;\n    variable\n) -> Mayer\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a DataType: NonFixed/Fixed, or with a boolean, variable, false by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1], Fixed)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Mayer","text":"Return the evaluation of the Mayer cost at x0, xf, v.\n\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Mayer","text":"Return the evaluation of the Mayer cost at x0, xf.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint","page":"CTBase API","title":"CTBase.MixedConstraint","text":"struct MixedConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Lagrange in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor MixedConstraint returns a MixedConstraint of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the MixedConstraint for given values.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"Return the value of the MixedConstraint function.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier","page":"CTBase API","title":"CTBase.Multiplier","text":"struct Multiplier{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to ControlLaw in the usage.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Multiplier returns a Multiplier of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Multiplier for given values.\n\nExamples\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Return the value of the Multiplier function.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.NonAutonomous","page":"CTBase API","title":"CTBase.NonAutonomous","text":"abstract type NonAutonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NonFixed","page":"CTBase API","title":"CTBase.NonFixed","text":"abstract type NonFixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NotImplemented","page":"CTBase API","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlModel","page":"CTBase API","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel\n\nFields\n\nmodel_expression::Union{Nothing, Expr}: Default: nothing\ninitial_time::Union{Nothing, Index, Real}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time::Union{Nothing, Index, Real}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, Lagrange}: Default: nothing\nmayer::Union{Nothing, Mayer}: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, Dynamics}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlSolution","page":"CTBase API","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\ntimes::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nstate::Union{Nothing, Function}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nvariable::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncostate::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Integer}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ParsingError","page":"CTBase API","title":"CTBase.ParsingError","text":"struct ParsingError <: CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.PrintCallback","page":"CTBase API","title":"CTBase.PrintCallback","text":"mutable struct PrintCallback <: CTCallback\n\nCallback for printing.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.PrintCallback-Tuple","page":"CTBase API","title":"CTBase.PrintCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint","page":"CTBase API","title":"CTBase.StateConstraint","text":"struct StateConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor StateConstraint returns a StateConstraint of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the StateConstraint for given values.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"Return the value of the StateConstraint function.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.States","page":"CTBase API","title":"CTBase.States","text":"Type alias for a vector of states.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StopCallback","page":"CTBase API","title":"CTBase.StopCallback","text":"Stopping callback.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StopCallback-Tuple","page":"CTBase API","title":"CTBase.StopCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Time","page":"CTBase API","title":"CTBase.Time","text":"Type alias for a time.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimeDependence","page":"CTBase API","title":"CTBase.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Times","page":"CTBase API","title":"CTBase.Times","text":"Type alias for a vector of times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.UnauthorizedCall","page":"CTBase API","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint","page":"CTBase API","title":"CTBase.VariableConstraint","text":"struct VariableConstraint\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VariableConstraint returns a VariableConstraint of a function. The function must take 1 argument, v.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\n\nwarning: Warning\nWhen the variable is of dimension 1, consider v as a scalar.\n\nCall\n\nThe call returns the evaluation of the VariableConstraint for given values.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VariableConstraint","text":"Return the value of the VariableConstraint function.\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VariableDependence","page":"CTBase API","title":"CTBase.VariableDependence","text":"abstract type VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField","page":"CTBase API","title":"CTBase.VectorField","text":"struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VectorField returns a VectorField of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the VectorField for given values.\n\nExamples\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VectorField","text":"Return the value of the VectorField.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctNumber","page":"CTBase API","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(X::Function, f::Function) -> Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#105#107\"\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#109#111\"\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n\n\nLie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{VectorField, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(X::VectorField, f::Function) -> Function\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField{Autonomous}\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(\n    X::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::Function; autonomous, variable) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{VectorField}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::VectorField) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{Vararg{DataType}}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following argument:\n\ndependencies: either Autonomous or NonAutonomous. Default is Autonomous. And either NonFixed or Fixed. Default is Fixed.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\nautonomous: either true or false. Default is true.\nvariable: either true or false. Default is false.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift{Autonomous}\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift{NonAutonomous}\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y at the tuple of descriptions x if it is not already in the tuple x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions = add(descriptions, (:b,))\n((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint!","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial or :final value constraint on a range of the state, or a value constraint on a range of the :variable.\n\nnote: Note\nThe range of the constraint must be contained in 1:n if the constraint is on the state, or 1:q if the constraint is on the variable.\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\n\nExamples\n\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ])\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ])\njulia> constraint!(ocp, :final, Index(2), 0)\njulia> constraint!(ocp, :variable, 2:3, [ 0, 3 ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.constraint!-2","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial, :final, :control, :state or :variable box constraint (whole range).\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> constraint!(ocp, :initial, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :control, [ 0, 0 ], [ 2, 3 ])\njulia> constraint!(ocp, :state, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 0, 1) # the variable here is of dimension 1\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.constraint!-3","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial or :final value constraint on the state, or a :variable value. Can also be used with :state and :control.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> constraint!(ocp, :initial, [ 0, 0 ])\njulia> constraint!(ocp, :final, 2) # if the state is of dimension 1\njulia> constraint!(ocp, :variable, [ 3, 0, 1 ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.constraint!-4","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd a :boundary, :control, :state, :mixed or :variable value functional constraint.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[2], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u+v[1], 0)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u-t*v[2], 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t+v[1], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]-u*v[1], 0)\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.constraint!-Tuple{OptimalControlModel, Symbol}","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol;\n    rg,\n    f,\n    val,\n    lb,\n    ub,\n    label\n)\n\n\nAdd an :initial, :final, :control, :state or :variable box constraint on a range.\n\nnote: Note\nThe range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\n\nExamples\n\njulia> constraint!(ocp, :initial, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :control, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :state, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial, rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint!-Union{Tuple{V}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial, :final, :control, :state or :variable box constraint on a range.\n\nnote: Note\nThe range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\n\nExamples\n\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :final, Index(1), 0, 2)\njulia> constraint!(ocp, :control, Index(1), 0, 2)\njulia> constraint!(ocp, :state, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 1:2, [ 0, 0 ], [ 1, 2 ])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where {T, V}","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd a :boundary, :control, :state, :mixed or :variable box functional constraint.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0, 1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0, 1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 0, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0, 1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 0, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0, 1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 0, 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u, v) -> x[1]-v[2]*u, 0, 1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u+v[2], 0, 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t*v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]*v[2]-u, 0, 1)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint_type-NTuple{7, Any}","page":"CTBase API","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...)\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, Index(1))\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, Index(1))\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, Index(1))\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, Index(1))\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, Index(2))\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v ^ 2 + 1))\n\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v[2] ^ 2 + 1))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\nExample\n\njulia> constraints_labels(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control!","page":"CTBase API","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.ct_repl-Tuple{}","page":"CTBase API","title":"CTBase.ct_repl","text":"ct_repl(; debug, demo) -> Any\n\n\nCreate a ct REPL.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x::Real) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(X::VectorField, x) -> Any\n\n\nReturn the gradient of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctindices-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"CTBase API","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x::Real) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(X::VectorField, x) -> Any\n\n\nReturn the Jacobian of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctupperscripts-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.dynamics!","text":"dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n\n\nSet the dynamics.\n\nnote: Note\nYou can use dynamics! only once to define the dynamics.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> dynamics!(ocp, f)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase API","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n((:a, :b), (:b, :c), (:a, :c))\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"CTBase API","title":"CTBase.get_priority_print_callbacks","text":"get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority print callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"CTBase API","title":"CTBase.get_priority_stop_callbacks","text":"get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority stop callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_max-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_max","text":"is_max(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_min-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_min","text":"is_min(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_dependent-Tuple{OptimalControlModel{NonAutonomous}}","page":"CTBase API","title":"CTBase.is_time_dependent","text":"is_time_dependent(\n    ocp::OptimalControlModel{NonAutonomous}\n) -> Bool\n\n\nReturn true if the model has been defined as time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_time_independent","text":"is_time_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","page":"CTBase API","title":"CTBase.is_variable_dependent","text":"is_variable_dependent(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n\n\nReturn true if the model has been defined as variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_variable_independent","text":"is_variable_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.nlp_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.nlp_constraints","text":"nlp_constraints(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Vector{Real}, CTBase.var\"#ξ#99\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#η#100\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ψ#101\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ϕ#102\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#θ#103\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(θl, θ, θu) are variable constraints\n(ul, uind, uu) are control linear constraints of a subset of indices\n(xl, xind, xu) are state linear constraints of a subset of indices\n(vl, vind, vu) are variable linear constraints of a subset of indices\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints.\n\nExample\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"CTBase API","title":"CTBase.remove_constraint!","text":"remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state!","page":"CTBase API","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real}\n) -> Any\ntime!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real},\n    name::String\n) -> Any\n\n\nFix initial and final times to times[1] and times[2], respectively.\n\nExamples\n\njulia> time!(ocp, [ 0, 1 ])\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, [ 0, 1 ], \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, [ 0, 1 ], :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-2","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real,\n    name::String\n)\n\n\nFix final time, initial time is free and given by the variable at the provided index.\n\nExamples\n\njulia> time!(ocp, Index(2), 1, \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-3","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index,\n    name::String\n)\n\n\nInitial and final times are free and given by the variable at the provided indices.\n\nExamples\n\njulia> time!(ocp, Index(2), Index(3), \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-4","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index,\n    name::String\n)\n\n\nFix initial time, final time is free and given by the variable at the provided index.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, 0, Index(2), \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.time!-5","page":"CTBase API","title":"CTBase.time!","text":"time!(ocp::OptimalControlModel, t0::Real, tf::Real)\ntime!(\n    ocp::OptimalControlModel,\n    t0::Real,\n    tf::Real,\n    name::String\n)\n\n\nFix initial and final times to times[1] and times[2], respectively.\n\nExamples\n\njulia> time!(ocp, 0, 1)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, 0, 1, \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, 0, 1, :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.variable!","page":"CTBase API","title":"CTBase.variable!","text":"variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension when the model is NonFixed.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.∂ₜ-Tuple{Any}","page":"CTBase API","title":"CTBase.∂ₜ","text":"∂ₜ(f) -> CTBase.var\"#114#116\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#RecipesBase.plot!-Tuple{Plots.Plot, OptimalControlSolution}","page":"CTBase API","title":"RecipesBase.plot!","text":"plot!(\n    p::Plots.Plot,\n    sol::OptimalControlSolution;\n    layout,\n    control,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the optimal control solution sol using the layout layout.\n\nNotes.\n\nThe argument layout can be :group or :split (default).\nThe keyword arguments state_style, control_style and costate_style are passed to the plot function of the Plots package. The state_style is passed to the plot of the state, the control_style is passed to the plot of the control and the costate_style is passed to the plot of the costate.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#RecipesBase.plot-Tuple{OptimalControlSolution}","page":"CTBase API","title":"RecipesBase.plot","text":"plot(\n    sol::OptimalControlSolution;\n    layout,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Any\n\n\nPlot the optimal control solution sol using the layout layout.\n\nNotes.\n\nThe argument layout can be :group or :split (default).\nThe keyword arguments state_style, control_style and costate_style are passed to the plot function of the Plots package. The state_style is passed to the plot of the state, the control_style is passed to the plot of the control and the costate_style is passed to the plot of the costate.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1,0,7])\n3.0\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@def","page":"CTBase API","title":"CTBase.@def","text":"Define an optimal control problem. One pass parsing of the definition.\n\nExample\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n\n\n\n\n","category":"macro"},{"location":"rk.html#Runge-Kutta-method","page":"Runge Kutta method","title":"Runge Kutta method","text":"","category":"section"},{"location":"rk.html","page":"Runge Kutta method","title":"Runge Kutta method","text":"For the moment we have implemented only the trapeze method for the discretization","category":"page"}]
}
