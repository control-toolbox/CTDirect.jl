var documenterSearchIndex = {"docs":
[{"location":"api.html#CTDirect-API","page":"API","title":"CTDirect API","text":"","category":"section"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html","page":"API","title":"API","text":"","category":"page"},{"location":"dev-api.html#Internal-functions","page":"Developers","title":"Internal functions","text":"","category":"section"},{"location":"dev-api.html","page":"Developers","title":"Developers","text":"CurrentModule = CTDirect ","category":"page"},{"location":"dev-api.html","page":"Developers","title":"Developers","text":"Modules = [CTDirect]\nOrder = [:module, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"dev-api.html#CTDirect.DOCP","page":"Developers","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\ndata required to link the OCP with the discretized DOCP\n\n\n\n\n\n","category":"type"},{"location":"dev-api.html#CTDirect.Gauss_Legendre_1","page":"Developers","title":"CTDirect.Gauss_Legendre_1","text":"Implicit Midpoint discretization, formulated as a generic IRK (ie Gauss Legendre 1) For testing purpose only, use :midpoint instead (cf midpoint.jl) !\n\n\n\n\n\n","category":"type"},{"location":"dev-api.html#CTDirect.Gauss_Legendre_2","page":"Developers","title":"CTDirect.Gauss_Legendre_2","text":"Gauss Legendre 2 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"dev-api.html#CTDirect.Gauss_Legendre_3","page":"Developers","title":"CTDirect.Gauss_Legendre_3","text":"Gauss Legendre 3 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"dev-api.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"Developers","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"Developers","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"Developers","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_Hessian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"Developers","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"Developers","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"Developers","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"Developers","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_Jacobian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"Developers","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, CTDirect.DOCP}","page":"Developers","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the constraints C for the DOCP problem (modeled as LB <= C(X) <= UB).\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_initial_guess","page":"Developers","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(docp::CTDirect.DOCP) -> Vector{Float64}\nDOCP_initial_guess(\n    docp::CTDirect.DOCP,\n    init::CTModels.Init\n) -> Vector{Float64}\n\n\nBuild initial guess for discretized problem\n\n\n\n\n\n","category":"function"},{"location":"dev-api.html#CTDirect.DOCP_objective-Tuple{Any, CTDirect.DOCP}","page":"Developers","title":"CTDirect.DOCP_objective","text":"DOCP_objective(xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the objective for the DOCP problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.IRK_dims-NTuple{7, Any}","page":"Developers","title":"CTDirect.IRK_dims","text":"IRK_dims(\n    dim_NLP_steps,\n    dim_NLP_x,\n    dim_NLP_u,\n    dim_NLP_v,\n    dim_path_cons,\n    dim_boundary_cons,\n    stage\n) -> NTuple{5, Any}\n\n\nReturn the dimension of the NLP variables and constraints for a generic IRK discretizion, with the control taken constant per step (ie not distinct controls at time stages)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.SolverInfos-Tuple{}","page":"Developers","title":"CTDirect.SolverInfos","text":"SolverInfos() -> Tuple{Int64, Float64, String, Symbol, Bool}\n\n\nRetrieve convergence information (Ipopt version)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__adnlp_backend-Tuple{}","page":"Developers","title":"CTDirect.__adnlp_backend","text":"__adnlp_backend() -> Symbol\n\n\nUsed to set the default backend for AD in ADNLPModels. The default value is :manual.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__disc_method-Tuple{}","page":"Developers","title":"CTDirect.__disc_method","text":"__disc_method() -> Symbol\n\n\nUsed to set the default discretization method. The default value is trapeze.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__display-Tuple{}","page":"Developers","title":"CTDirect.__display","text":"__display() -> Bool\n\n\nUsed to set the default display toggle. The default value is true.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__grid_size-Tuple{}","page":"Developers","title":"CTDirect.__grid_size","text":"__grid_size() -> Int64\n\n\nUsed to set the default grid size. The default value is 250.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__ipopt_linear_solver-Tuple{}","page":"Developers","title":"CTDirect.__ipopt_linear_solver","text":"__ipopt_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of Ipopt for the direct method. The default value is mumps.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__ipopt_mu_strategy-Tuple{}","page":"Developers","title":"CTDirect.__ipopt_mu_strategy","text":"__ipopt_mu_strategy() -> String\n\n\nUsed to set the default value of the μ strategy of Ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__ipopt_print_level-Tuple{}","page":"Developers","title":"CTDirect.__ipopt_print_level","text":"__ipopt_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__knitro_print_level-Tuple{}","page":"Developers","title":"CTDirect.__knitro_print_level","text":"__knitro_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Knitro for the direct method. The default value is 3.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__madnlp_linear_solver-Tuple{}","page":"Developers","title":"CTDirect.__madnlp_linear_solver","text":"__madnlp_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of MadNLP for the direct method. The default value is umfpack.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__max_iterations-Tuple{}","page":"Developers","title":"CTDirect.__max_iterations","text":"__max_iterations() -> Int64\n\n\nUsed to set the default maximum of iterations. The default value is 1000.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__ocp_init-Tuple{}","page":"Developers","title":"CTDirect.__ocp_init","text":"__ocp_init()\n\n\nUsed to set the default initial guess. The default value is nothing and will correspond to 0.1 for all variables.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__time_grid-Tuple{}","page":"Developers","title":"CTDirect.__time_grid","text":"__time_grid()\n\n\nUsed to set the default time grid. The default value is nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__tolerance-Tuple{}","page":"Developers","title":"CTDirect.__tolerance","text":"__tolerance() -> Float64\n\n\nUsed to set the default tolerance. The default value is 1e-6.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.add_nonzero_block!-NTuple{5, Any}","page":"Developers","title":"CTDirect.add_nonzero_block!","text":"add_nonzero_block!(M, i_start, i_end, j_start, j_end; sym)\n\n\nAdd block of nonzeros elements to a sparsity pattern  Format: boolean matrix (M) or index vectors (Is, Js)  Includes a more compact method for single element case Option to add the symmetric block also (eg for Hessian) Note: independent from discretization scheme\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.available_methods-Tuple{}","page":"Developers","title":"CTDirect.available_methods","text":"available_methods(\n\n) -> Tuple{Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.build_OCP_solution-Tuple{Any, Any}","page":"Developers","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(\n    docp,\n    docp_solution\n) -> CTModels.Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, CTModels.DualModel{CTModels.var\"#70#83\"{Matrix{Float64}}, CTModels.var\"#71#84\"{Matrix{Float64}}, Vector{Float64}, Vector{Float64}, CTModels.var\"#72#85\"{Matrix{Float64}, Int64}, CTModels.var\"#73#86\"{Matrix{Float64}, Int64}, CTModels.var\"#74#87\"{Matrix{Float64}, Int64}, CTModels.var\"#75#88\"{Matrix{Float64}, Int64}, Vector{Float64}, Vector{Float64}}, CTModels.SolverInfos{Dict{Symbol, Any}}} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#64#77\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#65#78\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#66#79\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#67#80\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#68#81\", CTModels.var\"#69#82\"}}\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.build_OCP_solution-Tuple{Any}","page":"Developers","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(docp; primal, dual, mult_LB, mult_UB)\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.build_bounds-Tuple{Any, Any, Any}","page":"Developers","title":"CTDirect.build_bounds","text":"build_bounds(\n    dim_var,\n    dim_box,\n    box_triplet\n) -> Tuple{Any, Any}\n\n\nBuild full, ordered sets of bounds for state, control or optimization variables\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.constraints_bounds!-Tuple{CTDirect.DOCP}","page":"Developers","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP nonlinear constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.direct_transcription-Tuple{CTModels.Model, Vararg{Any}}","page":"Developers","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::CTModels.Model,\n    description...;\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    adnlp_backend,\n    solver_backend,\n    show_time,\n    matrix_free\n) -> Tuple{CTDirect.DOCP{_A, CTModels.Model{TimesModelType, StateModelType, ControlModelType, VariableModelType, DynamicsModelType, ObjectiveModelType, ConstraintsModelType}} where {_A<:CTDirect.Discretization, TimesModelType<:CTModels.AbstractTimesModel, StateModelType<:CTModels.AbstractStateModel, ControlModelType<:CTModels.AbstractControlModel, VariableModelType<:CTModels.AbstractVariableModel, DynamicsModelType<:Function, ObjectiveModelType<:CTModels.AbstractObjectiveModel, ConstraintsModelType<:CTModels.AbstractConstraintsModel}, ADNLPModels.ADNLPModel{Float64, Vector{Float64}, Vector{Int64}}}\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem (ie direct transcription)\n\nArguments\n\nocp: optimal control problem as defined in CTModels\n[description]: can specifiy for instance the NLP model and / or solver (:ipopt, :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :euler, :euler_implicit, :midpoint, gauss_legendre_2, gauss_legendre_3)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values as named tuple or existing solution)\nadnlp_backend: backend for automatic differentiation in ADNLPModels ([:optimized], :manual, :default)\nshow_time: (:true, [:false]) show timing details from ADNLPModels\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Developers","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1), with convention u(tf) = U_N Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Euler}, Any}","page":"Developers","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: see above for acplicit / implicit versions Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_OCP_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Developers","title":"CTDirect.get_OCP_state_at_time_step","text":"get_OCP_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_OCP_variable-Tuple{Any, CTDirect.DOCP}","page":"Developers","title":"CTDirect.get_OCP_variable","text":"get_OCP_variable(xu, docp::CTDirect.DOCP) -> Any\n\n\nRetrieve optimization variables from the NLP variables. Convention: stored at the end, hence not dependent on the discretization method Vector output\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_lagrange_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Developers","title":"CTDirect.get_lagrange_state_at_time_step","text":"get_lagrange_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variable for lagrange cost at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1   (no check for actual lagrange cost presence !)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_stagevars_at_time_step-Tuple{Any, CTDirect.DOCP, Any, Any}","page":"Developers","title":"CTDirect.get_stagevars_at_time_step","text":"get_stagevars_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i,\n    j\n) -> Any\n\n\nRetrieve stage variables at given time step/stage from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1),\t1 <= j <= s Vector output Note that passing correct indices is up to the caller, no checks are made here.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_time_grid-Tuple{Any, CTDirect.DOCP}","page":"Developers","title":"CTDirect.get_time_grid","text":"get_time_grid(xu, docp::CTDirect.DOCP) -> Any\n\n\nReturn time grid for variable time problems (times are then dependent on NLP variables)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.is_solvable-Tuple{Any}","page":"Developers","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.parse_DOCP_solution_dual-Tuple{Any, Any, Any}","page":"Developers","title":"CTDirect.parse_DOCP_solution_dual","text":"parse_DOCP_solution_dual(\n    docp,\n    multipliers,\n    constraints\n) -> NTuple{5, Any}\n\n\nRecover OCP costate and constraints multipliers from DOCP multipliers\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.parse_DOCP_solution_primal-Tuple{Any, Any}","page":"Developers","title":"CTDirect.parse_DOCP_solution_primal","text":"parse_DOCP_solution_primal(\n    docp,\n    solution;\n    mult_LB,\n    mult_UB\n) -> Tuple{Any, Any, Any, NTuple{6, Any}}\n\n\nRecover OCP primal variables from DOCP solution\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setPointConstraints!-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"Developers","title":"CTDirect.setPointConstraints!","text":"setPointConstraints!(docp::CTDirect.DOCP, c, xu, v) -> Any\n\n\nSet the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Vararg{Any, 6}}","page":"Developers","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps (+1)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Euler}, Vararg{Any, 6}}","page":"Developers","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Vararg{Any, 6}}","page":"Developers","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Vararg{Any, 6}}","page":"Developers","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"Developers","title":"CTDirect.setWorkArray","text":"setWorkArray(docp::CTDirect.DOCP, xu, time_grid, v) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any, Any}","page":"Developers","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Euler}, Any, Any, Any}","page":"Developers","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Any, Any}","page":"Developers","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Any, Any}","page":"Developers","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.set_control_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"Developers","title":"CTDirect.set_control_at_time_step!","text":"set_control_at_time_step!(\n    xu,\n    u_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for control variables at given time step Convention: 1 <= i <= dimNLPsteps(+1)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.set_initial_guess-Tuple{CTDirect.DOCP, Any, Any}","page":"Developers","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, nlp, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.set_optim_variable!-Tuple{Any, Any, Any}","page":"Developers","title":"CTDirect.set_optim_variable!","text":"set_optim_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.set_state_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"Developers","title":"CTDirect.set_state_at_time_step!","text":"set_state_at_time_step!(\n    xu,\n    x_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for state variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.solve-Tuple{CTModels.Model, Vararg{Symbol}}","page":"Developers","title":"CTDirect.solve","text":"solve(\n    ocp::CTModels.Model,\n    description::Symbol...;\n    display,\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    adnlp_backend,\n    kwargs...\n)\n\n\nSolve an OCP with a direct method\n\nArguments\n\nocp: optimal control problem as defined in CTBase\n[description]: can specifiy for instance the NLP model and / or solver (:ipopt, :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ndisplay: ([true], false) will disable output if set to false\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :midpoint, gauss_legendre_2)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values or existing solution)\nadnlp_backend: backend for automatic differentiation in ADNLPModels ([:optimized], :manual, :default)\n\nAll further keywords are passed to the inner call of solve_docp\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.variables_bounds!-Tuple{CTDirect.DOCP}","page":"Developers","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html","page":"Developers","title":"Developers","text":"","category":"page"},{"location":"index.html#CTDirect.jl","page":"Introduction","title":"CTDirect.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  CTDirect","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"flowchart TD\nB(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctbase.html'>CTBase</a>)\nM(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctmodels.html'>CTModels</a>)\nP(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctparser.html'>CTParser</a>)\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-optimalcontrol.html'>OptimalControl</a>)\nD(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctdirect.html'>CTDirect</a>)\nF(<a href='https://control-toolbox.org/OptimalControl.jl/stable/api-ctflows.html'>CTFlows</a>)\nO --> D\nO --> M\nO --> F\nO --> P\nF --> M\nO --> B\nF --> B\nD --> B\nD --> M\nP --> B\nM --> B\nstyle D fill:#FBF275","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install\nTo install a package from the control-toolbox ecosystem,  please visit the installation page.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An optimal control problem with fixed initial and final times, denoted (OCP), can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The so-called direct approach transforms the infinite dimensional optimal control problem (OCP) into a finite dimensional optimization problem (NLP). This is done by a discretization in time by Runge-Kutta methods applied to the state and control variables, as well as the dynamics equation. These methods are usually less precise than indirect methods based on Pontryagin’s Maximum Principle, but more robust with respect to the initialization. Also, they are more straightforward to apply, hence their wide use in industrial applications. We refer the reader to for instance[1] and [2] for more details on direct transcription methods and NLP algorithms.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1]: J. T. Betts. Practical methods for optimal control using nonlinear programming. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2001.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[2]: J. Nocedal and S.J. Wright. Numerical optimization. Springer-Verlag, New York, 1999.****","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Example of the time discretization by the trapezoidal rule:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarraylcl\nt in t_0t_f    to  t_0 ldots t_N=t_f02em\nx(cdot) u(cdot)  to  X=x_0 ldots x_N u_0 ldots u_N 1em\nhline\n\ntextstep  to  h = (t_f-t_0)N02em\ntextcriterion  to  min g(x_0 x_N) 02em\ntextdynamics   to  x_i+i = x_i + (h2) (f(t_i x_i u_i) + f(t_i+1 x_i+1 u_i+1)) 02em\ntextcontrol constraints to xi_l  le  xi(t_i u_i)   le xi_u 02em\ntextpath constraints to eta_l le eta(t_i x_i)        le eta_u 02em\ntextmixed constraints to psi_l le psi(t_i x_i u_i) le psi_u 02em\ntextlimit conditions to phi_l le phi(x_0 x_N) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We therefore obtain a nonlinear programming problem on the discretized state and control variables of the general form:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(NLP)quad left\nbeginarraylr\nmin  F(X) \nLB le C(X) le UB\nendarray\nright","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Solving the (NLP) problem is done using packages from JuliaSmoothOptimizers, with Ipopt as the default solver.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"On the input side of this package, we use an OptimalControlModel structure from CTModels to define the (OCP).","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The direct transcription to build the (NLP) can use discretization schemes such as trapeze (default), midpoint, or Gauss-Legendre collocations.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Related packages\nThis package is a successor to the bocop software.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
