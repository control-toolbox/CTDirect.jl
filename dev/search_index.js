var documenterSearchIndex = {"docs":
[{"location":"api.html#CTDirect-API","page":"API","title":"CTDirect API","text":"","category":"section"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#CTDirect.available_methods-Tuple{}","page":"API","title":"CTDirect.available_methods","text":"available_methods(\n\n) -> Tuple{Tuple{Symbol, Symbol}, Tuple{Symbol, Symbol}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTDirect.direct_solve-Tuple{OptimalControlModel, Vararg{Symbol}}","page":"API","title":"CTDirect.direct_solve","text":"direct_solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    init,\n    grid_size,\n    time_grid,\n    discretization,\n    kwargs...\n) -> OptimalControlSolution\n\n\nSolve an OCP with a direct method\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTDirect.direct_transcription-Tuple{OptimalControlModel, Vararg{Any}}","page":"API","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::OptimalControlModel,\n    description...;\n    init,\n    grid_size,\n    time_grid,\n    discretization\n) -> Tuple{Union{CTDirect.DOCP{CTDirect.Midpoint}, CTDirect.DOCP{CTDirect.Trapeze}}, ADNLPModels.ADNLPModel{Float64, Vector{Float64}, Vector{Int64}}}\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem (ie direct transcription)\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTDirect.is_solvable-Tuple{Any}","page":"API","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTDirect.set_initial_guess-Tuple{CTDirect.DOCP, Any, Any}","page":"API","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, nlp, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"api.html","page":"API","title":"API","text":"export_ocp_solution\nimport_ocp_solution","category":"page"},{"location":"api.html#CTDirect.export_ocp_solution","page":"API","title":"CTDirect.export_ocp_solution","text":"export_ocp_solution(\n    sol::OptimalControlSolution;\n    filename_prefix\n)\n\n\nExport OCP solution in JSON format\n\n\n\n\n\n","category":"function"},{"location":"api.html#CTDirect.import_ocp_solution","page":"API","title":"CTDirect.import_ocp_solution","text":"import_ocp_solution(\n    ocp::OptimalControlModel;\n    filename_prefix\n) -> OptimalControlSolution\n\n\nRead OCP solution in JSON format\n\n\n\n\n\n","category":"function"},{"location":"api.html","page":"API","title":"API","text":"","category":"page"},{"location":"dev-api.html#Internal-functions","page":"Developers","title":"Internal functions","text":"","category":"section"},{"location":"dev-api.html","page":"Developers","title":"Developers","text":"CurrentModule = CTDirect ","category":"page"},{"location":"dev-api.html","page":"Developers","title":"Developers","text":"Modules = [CTDirect]\nOrder = [:module, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"dev-api.html#CTBase.OptimalControlSolution-Tuple{Any, Any}","page":"Developers","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(docp, docp_solution) -> Any\n\n\nBuild OCP functional solution from DOCP discrete solution (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTBase.OptimalControlSolution-Tuple{Any}","page":"Developers","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    docp;\n    primal,\n    dual,\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    mult_LB,\n    mult_UB\n) -> Any\n\n\nBuild OCP functional solution from the DOCP discrete solution, given as a vector. Costate will be retrieved from dual variables (multipliers) if available.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTBase.OptimalControlSolution-Tuple{OptimalControlModel, Vararg{Any, 5}}","page":"Developers","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocp::OptimalControlModel,\n    T,\n    X,\n    U,\n    v,\n    P;\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    stopping,\n    success,\n    constraints_types,\n    constraints_mult,\n    box_multipliers\n) -> OptimalControlSolution\n\n\nBuild OCP functional solution from DOCP vector solution (given as raw variables and multipliers plus some optional infos)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.ArgsAtTimeStep_Midpoint","page":"Developers","title":"CTDirect.ArgsAtTimeStep_Midpoint","text":"Useful values at a time step: time, state, control, dynamics...\n\n\n\n\n\n","category":"type"},{"location":"dev-api.html#CTDirect.ArgsAtTimeStep_Trapeze","page":"Developers","title":"CTDirect.ArgsAtTimeStep_Trapeze","text":"Useful values at a time step: time, state, control, dynamics...\n\n\n\n\n\n","category":"type"},{"location":"dev-api.html#CTDirect.DOCP","page":"Developers","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\ndata required to link the OCP with the discretized DOCP\n\n\n\n\n\n","category":"type"},{"location":"dev-api.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, CTDirect.DOCP}","page":"Developers","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the constraints C for the DOCP problem (modeled as LB <= C(X) <= UB).\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.DOCP_initial_guess","page":"Developers","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(docp::CTDirect.DOCP) -> Vector{Float64}\nDOCP_initial_guess(\n    docp::CTDirect.DOCP,\n    init::OptimalControlInit\n) -> Vector{Float64}\n\n\nBuild initial guess for discretized problem\n\n\n\n\n\n","category":"function"},{"location":"dev-api.html#CTDirect.DOCP_objective-Tuple{Any, CTDirect.DOCP}","page":"Developers","title":"CTDirect.DOCP_objective","text":"DOCP_objective(xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the objective for the DOCP problem.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__discretization-Tuple{}","page":"Developers","title":"CTDirect.__discretization","text":"__discretization() -> String\n\n\nUsed to set the default discretization method. The default value is trapeze.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__grid_size-Tuple{}","page":"Developers","title":"CTDirect.__grid_size","text":"__grid_size() -> Int64\n\n\nUsed to set the default grid size. The default value is 250.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__ipopt_linear_solver-Tuple{}","page":"Developers","title":"CTDirect.__ipopt_linear_solver","text":"__ipopt_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of Ipopt for the direct method. The default value is mumps.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__ipopt_mu_strategy-Tuple{}","page":"Developers","title":"CTDirect.__ipopt_mu_strategy","text":"__ipopt_mu_strategy() -> String\n\n\nUsed to set the default value of the μ strategy of Ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__ipopt_print_level-Tuple{}","page":"Developers","title":"CTDirect.__ipopt_print_level","text":"__ipopt_print_level() -> Int64\n\n\nUsed to set the default value of the print level of Ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__madnlp_linear_solver-Tuple{}","page":"Developers","title":"CTDirect.__madnlp_linear_solver","text":"__madnlp_linear_solver() -> String\n\n\nUsed to set the default value of the linear solver of MadNLP for the direct method. The default value is umfpack.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__max_iterations-Tuple{}","page":"Developers","title":"CTDirect.__max_iterations","text":"__max_iterations() -> Int64\n\n\nUsed to set the default maximum of iterations. The default value is 1000.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__time_grid-Tuple{}","page":"Developers","title":"CTDirect.__time_grid","text":"__time_grid()\n\n\nUsed to set the default time grid. The default value is nothing.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.__tolerance-Tuple{}","page":"Developers","title":"CTDirect.__tolerance","text":"__tolerance() -> Float64\n\n\nUsed to set the default tolerance. The default value is 1e-8.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.build_bounds-Tuple{Any, Any, Any}","page":"Developers","title":"CTDirect.build_bounds","text":"build_bounds(\n    dim_var,\n    dim_box,\n    box_triplet\n) -> Tuple{Any, Any}\n\n\nBuild full, ordered sets of bounds for state, control or optimization variables\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.constraints_bounds!-Tuple{CTDirect.DOCP}","page":"Developers","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP nonlinear constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_final_time-Tuple{Any, Any}","page":"Developers","title":"CTDirect.get_final_time","text":"get_final_time(xu, docp) -> Any\n\n\nRetrieve final time for OCP (may be fixed or variable)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_initial_time-Tuple{Any, Any}","page":"Developers","title":"CTDirect.get_initial_time","text":"get_initial_time(xu, docp) -> Any\n\n\nRetrieve initial time for OCP (may be fixed or variable)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_optim_variable-Tuple{Any, Any}","page":"Developers","title":"CTDirect.get_optim_variable","text":"get_optim_variable(xu, docp) -> Any\n\n\nRetrieve optimization variables from the NLP variables.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_time_grid-Tuple{Any, Any}","page":"Developers","title":"CTDirect.get_time_grid","text":"get_time_grid(xu, docp) -> Any\n\n\nGet full (un-normalized) time grid\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_variables_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Midpoint}, Any}","page":"Developers","title":"CTDirect.get_variables_at_time_step","text":"get_variables_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    i\n) -> NTuple{4, Any}\n\n\nRetrieve state and control variables at given time step from the NLP variables.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.get_variables_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Trapeze}, Any}","page":"Developers","title":"CTDirect.get_variables_at_time_step","text":"get_variables_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    i\n) -> Tuple{Any, Any, Any}\n\n\nRetrieve state and control variables at given time step from the NLP variables. \n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.parse_DOCP_solution_dual-Tuple{Any, Any, Any}","page":"Developers","title":"CTDirect.parse_DOCP_solution_dual","text":"parse_DOCP_solution_dual(\n    docp,\n    multipliers,\n    constraints\n) -> Tuple{Any, Tuple{Any, Any, Any, Vector{Float64}, Vector{Float64}}, Tuple{Any, Any, Any, Vector{Float64}, Vector{Float64}}}\n\n\nRecover OCP costate and constraints multipliers from DOCP multipliers\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.parse_DOCP_solution_primal-Tuple{Any, Any}","page":"Developers","title":"CTDirect.parse_DOCP_solution_primal","text":"parse_DOCP_solution_primal(\n    docp,\n    solution;\n    mult_LB,\n    mult_UB\n) -> Tuple{Any, Any, Any, Tuple{Tuple{Any, Any}, Tuple{Any, Any}, Tuple{Any, Any}}}\n\n\nRecover OCP primal variables from DOCP solution\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setPathBounds!-Tuple{CTDirect.DOCP, Int64, Any, Any}","page":"Developers","title":"CTDirect.setPathBounds!","text":"setPathBounds!(\n    docp::CTDirect.DOCP,\n    index::Int64,\n    lb,\n    ub\n) -> Int64\n\n\nSet bounds for the path constraints at given time step\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setPathConstraints!-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Int64, Any, Any, Int64}","page":"Developers","title":"CTDirect.setPathConstraints!","text":"setPathConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    c,\n    index::Int64,\n    args,\n    v,\n    i::Int64\n) -> Int64\n\n\nSet the path constraints at given time step\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setPathConstraints!-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Int64, Any, Any, Int64}","page":"Developers","title":"CTDirect.setPathConstraints!","text":"setPathConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    c,\n    index::Int64,\n    args,\n    v,\n    i::Int64\n) -> Int64\n\n\nSet the path constraints at given time step\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setPointBounds!-Tuple{CTDirect.DOCP, Int64, Any, Any}","page":"Developers","title":"CTDirect.setPointBounds!","text":"setPointBounds!(\n    docp::CTDirect.DOCP,\n    index::Int64,\n    lb,\n    ub\n) -> Int64\n\n\nSet bounds for the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setPointConstraints!-Tuple{CTDirect.DOCP, Any, Int64, Any, Any}","page":"Developers","title":"CTDirect.setPointConstraints!","text":"setPointConstraints!(\n    docp::CTDirect.DOCP,\n    c,\n    index::Int64,\n    xu,\n    v\n) -> Int64\n\n\nSet the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setStateEquation!-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Int64, Any, Any, Any}","page":"Developers","title":"CTDirect.setStateEquation!","text":"setStateEquation!(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    c,\n    index::Int64,\n    args,\n    v,\n    i\n) -> Int64\n\n\nSet the constraints corresponding to the state equation\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.setStateEquation!-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Int64, Any, Any, Any}","page":"Developers","title":"CTDirect.setStateEquation!","text":"setStateEquation!(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    c,\n    index::Int64,\n    args,\n    v,\n    i\n) -> Int64\n\n\nSet the constraints corresponding to the state equation\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.set_box_multipliers-NTuple{4, Any}","page":"Developers","title":"CTDirect.set_box_multipliers","text":"set_box_multipliers(\n    T,\n    box_multipliers,\n    dim_x,\n    dim_u\n) -> Tuple{CTDirect.var\"#28#30\", CTDirect.var\"#29#31\", CTDirect.var\"#28#30\", CTDirect.var\"#29#31\", Any, Any}\n\n\nProcess data related to box constraints for solution building\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.set_constraints_and_multipliers-Tuple{Any, Any, Any}","page":"Developers","title":"CTDirect.set_constraints_and_multipliers","text":"set_constraints_and_multipliers(\n    T,\n    constraints_types,\n    constraints_mult\n) -> Tuple{CTDirect.var\"#16#22\", CTDirect.var\"#18#24\", CTDirect.var\"#20#26\", Any, Any, CTDirect.var\"#17#23\", CTDirect.var\"#19#25\", CTDirect.var\"#21#27\", Any, Any}\n\n\nProcess data related to constraints for solution building\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.set_optim_variable!-Tuple{Any, Any, Any}","page":"Developers","title":"CTDirect.set_optim_variable!","text":"set_optim_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#CTDirect.variables_bounds!-Tuple{CTDirect.DOCP}","page":"Developers","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html","page":"Developers","title":"Developers","text":"","category":"page"},{"location":"index.html#CTDirect.jl","page":"Introduction","title":"CTDirect.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  CTDirect","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"flowchart TD\nO(<a href='https://control-toolbox.org/OptimalControl.jl/stable/'>OptimalControl</a>) --> B(<a href='https://control-toolbox.org/CTBase.jl/stable/'>CTBase</a>)\nO --> D(<a href='https://control-toolbox.org/CTDirect.jl/stable/'>CTDirect</a>)\nO --> F(<a href='https://control-toolbox.org/CTFlows.jl/stable/'>CTFlows</a>)\nP(<a href='https://control-toolbox.org/CTProblems.jl/stable/'>CTProblems</a>) --> F\nP --> B\nF --> B\nD --> B\nstyle D fill:#FBF275","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install\nTo install a package from the control-toolbox ecosystem,  please visit the installation page.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An optimal control problem with fixed initial and final times, denoted (OCP), can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The so-called direct approach transforms the infinite dimensional optimal control problem (OCP) into a finite dimensional optimization problem (NLP). This is done by a discretization in time by Runge-Kutta methods applied to the state and control variables, as well as the dynamics equation. These methods are usually less precise than indirect methods based on Pontryagin’s Maximum Principle, but more robust with respect to the initialization. Also, they are more straightforward to apply, hence their wide use in industrial applications. We refer the reader to for instance[1] and [2] for more details on direct transcription methods and NLP algorithms.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1]: J. T. Betts. Practical methods for optimal control using nonlinear programming. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2001.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[2]: J. Nocedal and S.J. Wright. Numerical optimization. Springer-Verlag, New York, 1999.****","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Example of the time discretization by the trapezoidal rule:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarraylcl\nt in t_0t_f    to  t_0 ldots t_N=t_f02em\nx(cdot) u(cdot)  to  X=x_0 ldots x_N u_0 ldots u_N 1em\nhline\n\ntextstep  to  h = (t_f-t_0)N02em\ntextcriterion  to  min g(x_0 x_N) 02em\ntextdynamics   to  x_i+i = x_i + (h2) (f(t_i x_i u_i) + f(t_i+1 x_i+1 u_i+1)) 02em\ntextcontrol constraints to xi_l  le  xi(t_i u_i)   le xi_u 02em\ntextpath constraints to eta_l le eta(t_i x_i)        le eta_u 02em\ntextmixed constraints to psi_l le psi(t_i x_i u_i) le psi_u 02em\ntextlimit conditions to phi_l le phi(x_0 x_N) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We therefore obtain a nonlinear programming problem on the discretized state and control variables of the general form:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(NLP)quad left\nbeginarraylr\nmin  F(X) \nLB le C(X) le UB\nendarray\nright","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We use packages from JuliaSmoothOptimizers to solve the (NLP) problem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"As input of this package we use an OptimalControlModel structure from CTBase.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Current limitations\nThe current implemented is limited totrapezoidal rule for the ODE discretization\nIpopt for the optimization software","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Related packages\nThis package is equivalent to the bocop software.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"api-ctbase.html#CTBase-API","page":"CTBase API","title":"CTBase API","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"This is just a dump of CTBase API documentation. For more details about CTBase.jl package, see the documentation.","category":"page"},{"location":"api-ctbase.html#Index","page":"CTBase API","title":"Index","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Pages   = [\"api-ctbase.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"api-ctbase.html#Documentation","page":"CTBase API","title":"Documentation","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase API","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataStructures\nDocStringExtensions\nLinearAlgebra\nMLStyle\nParameters\nPrettyTables\nPrintf\nReplMaker\nUnicode\n\nList of all the exported names:\n\nAbstractHamiltonian\nAmbiguousDescription\nAutonomous\nBoundaryConstraint\nCTException\nControl\nControlConstraint\nControlLaw\nControls\nCostate\nCostates\nDCostate\nDState\nDescription\nDimension\nDynamics\nExtensionError\nFeedbackControl\nFixed\nHamiltonian\nHamiltonianLift\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrange\n@Lie\nLie\nLift\nMayer\nMixedConstraint\nModel\nMultiplier\nNonAutonomous\nNonFixed\nNotImplemented\nOptimalControlInit\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPoisson\nState\nStateConstraint\nStates\nTime\nTimeDependence\nTimes\nTimesDisc\nUnauthorizedCall\nVariable\nVariableConstraint\nVariableDependence\nVectorField\n__OCPModel\nadd\nboundary_constraints\nboundary_constraints!\nconstraint\nconstraint!\nconstraint_type\nconstraints_labels\ncontrol\ncontrol!\ncontrol_components_names\ncontrol_constraints\ncontrol_constraints!\ncontrol_dimension\ncontrol_discretized\ncontrol_name\ncostate\ncostate!\ncostate_discretized\ncriterion\nctNumber\nctVector\nct_repl\nct_repl_update_model\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\n@def\ndim_boundary_constraints\ndim_control_constraints\ndim_control_range\ndim_mixed_constraints\ndim_path_constraints\ndim_state_constraints\ndim_state_range\ndim_variable_constraints\ndim_variable_range\ndynamics\ndynamics!\nfinal_time\nfinal_time_name\ngetFullDescription\nhas_free_final_time\nhas_free_initial_time\nhas_lagrange_cost\nhas_mayer_cost\ninfos\ninfos!\ninitial_time\ninitial_time_name\nis_autonomous\nis_fixed\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\niterations\niterations!\nlagrange\nmayer\nmessage\nmessage!\nmixed_constraints\nmixed_constraints!\nmodel_expression\nmult_boundary_constraints\nmult_boundary_constraints!\nmult_control_box_lower\nmult_control_box_lower!\nmult_control_box_upper\nmult_control_box_upper!\nmult_control_constraints\nmult_control_constraints!\nmult_mixed_constraints\nmult_mixed_constraints!\nmult_state_box_lower\nmult_state_box_lower!\nmult_state_box_upper\nmult_state_box_upper!\nmult_state_constraints\nmult_state_constraints!\nmult_variable_box_lower\nmult_variable_box_lower!\nmult_variable_box_upper\nmult_variable_box_upper!\nmult_variable_constraints\nmult_variable_constraints!\nnlp_constraints!\nobjective\nobjective!\nremove\nremove_constraint!\nreplace_call\nset_AD_backend\nstate\nstate!\nstate_components_names\nstate_constraints\nstate_constraints!\nstate_dimension\nstate_discretized\nstate_name\nstopping\nstopping!\nsuccess\nsuccess!\ntime!\ntime_grid\ntime_grid!\ntime_name\nvariable\nvariable!\nvariable_components_names\nvariable_constraints\nvariable_constraints!\nvariable_dimension\nvariable_name\n∂ₜ\n⋅\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html#CTBase.Control","page":"CTBase API","title":"CTBase.Control","text":"Type alias for a control in Rᵐ.\n\njulia> const Control = ctVector\n\nSee also: ctVector, State, Costate, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costate","page":"CTBase API","title":"CTBase.Costate","text":"Type alias for a costate in Rⁿ.\n\njulia> const Costate = ctVector\n\nSee also: ctVector, State, Control, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DCostate","page":"CTBase API","title":"CTBase.DCostate","text":"Type alias for a tangent vector to the costate space.\n\njulia> const DCostate = ctVector\n\nSee also: ctVector, DState.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.DState","page":"CTBase API","title":"CTBase.DState","text":"Type alias for a tangent vector to the state space.\n\njulia> const DState = ctVector\n\nSee also: ctVector, DCostate.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.State","page":"CTBase API","title":"CTBase.State","text":"Type alias for a state in Rⁿ.\n\njulia> const State = ctVector\n\nSee also: ctVector, Costate, Control, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimesDisc","page":"CTBase API","title":"CTBase.TimesDisc","text":"Type alias for a grid of times. This is used to define a discretization of time interval given to solvers.\n\njulia> const TimesDisc = Union{Times, StepRangeLen}\n\nSee also: Time, Times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Variable","page":"CTBase API","title":"CTBase.Variable","text":"Type alias for a variable in Rᵏ.\n\njulia> const Variable = ctVector\n\nSee also: ctVector, State, Costate, Control.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ctVector","page":"CTBase API","title":"CTBase.ctVector","text":"Type alias for a vector of real numbers.\n\njulia> const ctVector = Union{ctNumber, AbstractVector{<:ctNumber}}\n\nSee also: ctNumber, State, Costate, Control, Variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AbstractHamiltonian","page":"CTBase API","title":"CTBase.AbstractHamiltonian","text":"abstract type AbstractHamiltonian{time_dependence, variable_dependence}\n\nAbstract type for hamiltonians.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.AmbiguousDescription","page":"CTBase API","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Autonomous","page":"CTBase API","title":"CTBase.Autonomous","text":"abstract type Autonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"struct BoundaryConstraint{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor BoundaryConstraint returns a BoundaryConstraint of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar. When the constraint is dimension 1, return a scalar.\n\nCall\n\nThe call returns the evaluation of the BoundaryConstraint for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored.\n\nExamples\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"BoundaryConstraint(\n    f::Function;\n    variable\n) -> BoundaryConstraint{Fixed}\n\n\nReturn a BoundaryConstraint of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.BoundaryConstraint","text":"Return the evaluation of the BoundaryConstraint.\n\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.CTException","page":"CTBase API","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint","page":"CTBase API","title":"CTBase.ControlConstraint","text":"struct ControlConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlConstraint returns a ControlConstraint of a function. The function must take 1 to 3 arguments, u to (t, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the control is of dimension 1, consider u as a scalar.\n\nCall\n\nThe call returns the evaluation of the ControlConstraint for given values.\n\nExamples\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n\n\nReturn the ControlConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlConstraint","text":"Return the value of the ControlConstraint function.\n\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw","page":"CTBase API","title":"CTBase.ControlLaw","text":"struct ControlLaw{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Hamiltonian in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor ControlLaw returns a ControlLaw of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the ControlLaw for given values.\n\nExamples\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Function}","page":"CTBase API","title":"CTBase.ControlLaw","text":"ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n\n\nReturn the ControlLaw of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.ControlLaw","text":"Return the value of the ControlLaw function.\n\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Controls","page":"CTBase API","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\njulia> const Controls = AbstractVector{<:Control}\n\nSee also: Control, States, Costates.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costates","page":"CTBase API","title":"CTBase.Costates","text":"Type alias for a vector of costates.\n\njulia> const Costates = AbstractVector{<:Costate}\n\nSee also: Costate, States, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Description","page":"CTBase API","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dimension","page":"CTBase API","title":"CTBase.Dimension","text":"Type alias for a dimension. This is used to define the dimension of the state space,  the costate space, the control space, etc.\n\njulia> const Dimension = Integer\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics","page":"CTBase API","title":"CTBase.Dynamics","text":"struct Dynamics{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Dynamics returns a Dynamics of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Dynamics for given values.\n\nExamples\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Function}","page":"CTBase API","title":"CTBase.Dynamics","text":"Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n\n\nReturn the Dynamics of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Dynamics","text":"Return the value of the Dynamics function.\n\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ExtensionError","page":"CTBase API","title":"CTBase.ExtensionError","text":"mutable struct ExtensionError <: CTException\n\nException thrown when an extension is not loaded but the user tries to call a function of it.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.FeedbackControl","page":"CTBase API","title":"CTBase.FeedbackControl","text":"struct FeedbackControl{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor FeedbackControl returns a FeedbackControl of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the FeedbackControl for given values.\n\nExamples\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Function}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n\n\nReturn the FeedbackControl of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.FeedbackControl","text":"Return the value of the FeedbackControl function.\n\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Fixed","page":"CTBase API","title":"CTBase.Fixed","text":"abstract type Fixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian","page":"CTBase API","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Hamiltonian returns a Hamiltonian of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Hamiltonian for given values.\n\nExamples\n\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Function}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n\n\nReturn an Hamiltonian of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Hamiltonian","text":"Return the value of the Hamiltonian.\n\njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence}\n\nLifts\n\nX::VectorField\n\nThe values for time_dependence and variable_dependence are deternimed by the values of those for the VectorField.\n\nConstructor\n\nThe constructor HamiltonianLift returns a HamiltonianLift of a VectorField.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed))\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianLift for given values.\n\nExamples\n\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\nAlternatively, it is possible to construct the HamiltonianLift from a Function being the VectorField.\n\njulia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n\n\nReturn an HamiltonianLift of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianLift","text":"Return the value of the HamiltonianLift.\n\nExamples\n\njulia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor HamiltonianVectorField returns a HamiltonianVectorField of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the HamiltonianVectorField for given values.\n\nExamples\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n\n\nReturn an HamiltonianVectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.HamiltonianVectorField","text":"Return the value of the HamiltonianVectorField.\n\nExamples\n\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.IncorrectArgument","page":"CTBase API","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectMethod","page":"CTBase API","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.IncorrectOutput","page":"CTBase API","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Index","page":"CTBase API","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Int64\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange","page":"CTBase API","title":"CTBase.Lagrange","text":"struct Lagrange{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Lagrange returns a Lagrange cost of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the Lagrange cost for given values.\n\nExamples\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Function}","page":"CTBase API","title":"CTBase.Lagrange","text":"Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n\n\nReturn a Lagrange cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Lagrange","text":"Return the value of the Lagrange function.\n\nExamples\n\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer","page":"CTBase API","title":"CTBase.Mayer","text":"struct Mayer{variable_dependence}\n\nFields\n\nf::Function\n\nThe default value for variable_dependence is Fixed.\n\nConstructor\n\nThe constructor Mayer returns a Mayer cost of a function. The function must take 2 or 3 arguments (x0, xf) or (x0, xf, v), if the function is variable, it must be specified.  Dependencies are specified with a boolean, variable, false by default or with a DataType, NonFixed/Fixed, Fixed by default.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x0 and xf as a scalar.\n\nCall\n\nThe call returns the evaluation of the Mayer cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored.\n\nExamples\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Mayer","text":"Mayer(\n    f::Function,\n    dependencies::DataType...\n) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Function}","page":"CTBase API","title":"CTBase.Mayer","text":"Mayer(f::Function; variable) -> Mayer{Fixed}\n\n\nReturn a Mayer cost of a function. Dependencies are specified with a boolean, variable, false by default.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Mayer","text":"Return the evaluation of the Mayer cost.\n\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1], Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint","page":"CTBase API","title":"CTBase.MixedConstraint","text":"struct MixedConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to Lagrange in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default value for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor MixedConstraint returns a MixedConstraint of a function. The function must take 2 to 4 arguments, (x, u) to (t, x, u, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar. Same for the control.\n\nCall\n\nThe call returns the evaluation of the MixedConstraint for given values.\n\nExamples\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n\n\nReturn the MixedConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.MixedConstraint","text":"Return the value of the MixedConstraint function.\n\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier","page":"CTBase API","title":"CTBase.Multiplier","text":"struct Multiplier{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to ControlLaw in the usage.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor Multiplier returns a Multiplier of a function. The function must take 2 to 4 arguments, (x, p) to (t, x, p, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state and costate are of dimension 1, consider x and p as scalars.\n\nCall\n\nThe call returns the evaluation of the Multiplier for given values.\n\nExamples\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Function}","page":"CTBase API","title":"CTBase.Multiplier","text":"Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n\n\nReturn the Multiplier of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.Multiplier","text":"Return the value of the Multiplier function.\n\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.NonAutonomous","page":"CTBase API","title":"CTBase.NonAutonomous","text":"abstract type NonAutonomous <: TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NonFixed","page":"CTBase API","title":"CTBase.NonFixed","text":"abstract type NonFixed <: VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.NotImplemented","page":"CTBase API","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlInit","page":"CTBase API","title":"CTBase.OptimalControlInit","text":"Initial guess for OCP, contains\n\nfunctions of time for the state and control variables\nvector for optimization variables\n\nInitialization data for each field can be left to default or: \n\nvector for optimization variables\nconstant / vector / function for state and control  \nexisting solution ('warm start') for all fields\n\nConstructors:\n\nOptimalControlInit(): default initialization\nOptimalControlInit(state, control, variable, time): constant vector, function handles and / or matrices / vectors interpolated along given time grid\nOptimalControlInit(sol): from existing solution\n\nExamples\n\njulia> init = OptimalControlInit()\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3)\njulia> init = OptimalControlInit(state=[0.1, 0.2], control=0.3, variable=0.5)\njulia> init = OptimalControlInit(state=[0.1, 0.2], controlt=t->sin(t), variable=0.5)\njulia> init = OptimalControlInit(state=[[0, 0], [1, 2], [5, -1]], time=[0, .3, 1.], controlt=t->sin(t))\njulia> init = OptimalControlInit(sol)\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlModel","page":"CTBase API","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel\n\nFields\n\nmodel_expression::Union{Nothing, Expr}: Default: nothing\ninitial_time::Union{Nothing, Index, Real}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time::Union{Nothing, Index, Real}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, Lagrange}: Default: nothing\nmayer::Union{Nothing, Mayer}: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, Dynamics}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\ndim_control_constraints::Union{Nothing, Integer}: Default: nothing\ndim_state_constraints::Union{Nothing, Integer}: Default: nothing\ndim_mixed_constraints::Union{Nothing, Integer}: Default: nothing\ndim_boundary_constraints::Union{Nothing, Integer}: Default: nothing\ndim_variable_constraints::Union{Nothing, Integer}: Default: nothing\ndim_control_range::Union{Nothing, Integer}: Default: nothing\ndim_state_range::Union{Nothing, Integer}: Default: nothing\ndim_variable_range::Union{Nothing, Integer}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlSolution","page":"CTBase API","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\ntime_grid::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\ninitial_time_name::Union{Nothing, String}: Default: nothing\nfinal_time_name::Union{Nothing, String}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_components_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_name::Union{Nothing, String}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_components_names::Union{Nothing, Vector{String}}: Default: nothing\nstate_name::Union{Nothing, String}: Default: nothing\nstate::Union{Nothing, Function}: Default: nothing\nvariable_dimension::Union{Nothing, Integer}: Default: nothing\nvariable_components_names::Union{Nothing, Vector{String}}: Default: nothing\nvariable_name::Union{Nothing, String}: Default: nothing\nvariable::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncostate::Union{Nothing, Function}: Default: nothing\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Int64}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\nboundary_constraints::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nmult_boundary_constraints::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nvariable_constraints::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nmult_variable_constraints::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nmult_variable_box_lower::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\nmult_variable_box_upper::Union{Nothing, Real, AbstractVector{<:Real}}: Default: nothing\ncontrol_constraints::Union{Nothing, Function}: Default: nothing\nmult_control_constraints::Union{Nothing, Function}: Default: nothing\nstate_constraints::Union{Nothing, Function}: Default: nothing\nmult_state_constraints::Union{Nothing, Function}: Default: nothing\nmixed_constraints::Union{Nothing, Function}: Default: nothing\nmult_mixed_constraints::Union{Nothing, Function}: Default: nothing\nmult_state_box_lower::Union{Nothing, Function}: Default: nothing\nmult_state_box_upper::Union{Nothing, Function}: Default: nothing\nmult_control_box_lower::Union{Nothing, Function}: Default: nothing\nmult_control_box_upper::Union{Nothing, Function}: Default: nothing\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.OptimalControlSolution-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"CTBase API","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed};\n    state,\n    control,\n    objective,\n    costate,\n    time_grid,\n    iterations,\n    stopping,\n    message,\n    success,\n    infos,\n    boundary_constraints,\n    mult_boundary_constraints,\n    control_constraints,\n    mult_control_constraints,\n    state_constraints,\n    mult_state_constraints,\n    mixed_constraints,\n    mult_mixed_constraints,\n    mult_state_box_lower,\n    mult_state_box_upper,\n    mult_control_box_lower,\n    mult_control_box_upper\n)\n\n\nConstructor from an optimal control problem for a Fixed ocp.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.OptimalControlSolution-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","page":"CTBase API","title":"CTBase.OptimalControlSolution","text":"OptimalControlSolution(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed};\n    state,\n    control,\n    objective,\n    variable,\n    costate,\n    time_grid,\n    iterations,\n    stopping,\n    message,\n    success,\n    infos,\n    boundary_constraints,\n    mult_boundary_constraints,\n    variable_constraints,\n    mult_variable_constraints,\n    mult_variable_box_lower,\n    mult_variable_box_upper,\n    control_constraints,\n    mult_control_constraints,\n    state_constraints,\n    mult_state_constraints,\n    mixed_constraints,\n    mult_mixed_constraints,\n    mult_state_box_lower,\n    mult_state_box_upper,\n    mult_control_box_lower,\n    mult_control_box_upper\n)\n\n\nConstructor from an optimal control problem for a NonFixed ocp.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ParsingError","page":"CTBase API","title":"CTBase.ParsingError","text":"struct ParsingError <: CTException\n\nException thrown for syntax error during abstract parsing.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StateConstraint","page":"CTBase API","title":"CTBase.StateConstraint","text":"struct StateConstraint{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nSimilar to VectorField in the usage, but the dimension of the output of the function f is arbitrary.\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor StateConstraint returns a StateConstraint of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the StateConstraint for given values.\n\nExamples\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Function}","page":"CTBase API","title":"CTBase.StateConstraint","text":"StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n\n\nReturn the StateConstraint of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.StateConstraint","text":"Return the value of the StateConstraint function.\n\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.States","page":"CTBase API","title":"CTBase.States","text":"Type alias for a vector of states.\n\njulia> const States = AbstractVector{<:State}\n\nSee also: State, Costates, Controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Time","page":"CTBase API","title":"CTBase.Time","text":"Type alias for a time.\n\njulia> const Time = ctNumber\n\nSee also: ctNumber, Times, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimeDependence","page":"CTBase API","title":"CTBase.TimeDependence","text":"abstract type TimeDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Times","page":"CTBase API","title":"CTBase.Times","text":"Type alias for a vector of times.\n\njulia> const Times = AbstractVector{<:Time}\n\nSee also: Time, TimesDisc.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.UnauthorizedCall","page":"CTBase API","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTException\n\nException thrown when a call to a function is not authorized.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint","page":"CTBase API","title":"CTBase.VariableConstraint","text":"struct VariableConstraint\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VariableConstraint returns a VariableConstraint of a function. The function must take 1 argument, v.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\n\nwarning: Warning\nWhen the variable is of dimension 1, consider v as a scalar.\n\nCall\n\nThe call returns the evaluation of the VariableConstraint for given values.\n\nExamples\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VariableConstraint","text":"Return the value of the VariableConstraint function.\n\njulia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VariableDependence","page":"CTBase API","title":"CTBase.VariableDependence","text":"abstract type VariableDependence\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField","page":"CTBase API","title":"CTBase.VectorField","text":"struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence}\n\nFields\n\nf::Function\n\nThe default values for time_dependence and variable_dependence are Autonomous and Fixed respectively.\n\nConstructor\n\nThe constructor VectorField returns a VectorField of a function. The function must take 1 to 3 arguments, x to (t, x, v), if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with :\n\nbooleans, autonomous and variable, respectively true and false by default \nDataType, Autonomous/NonAutonomous and NonFixed/Fixed, respectively Autonomous and Fixed by default.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\nwarning: Warning\nWhen the state is of dimension 1, consider x as a scalar.\n\nCall\n\nThe call returns the evaluation of the VectorField for given values.\n\nExamples\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed.\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Function}","page":"CTBase API","title":"CTBase.VectorField","text":"VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n\n\nReturn a VectorField of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default.\n\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.VectorField","text":"Return the value of the VectorField.\n\nExamples\n\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctNumber","page":"CTBase API","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(X::Function, f::Function) -> Function\n\n\nLie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#90#92\"{VectorField{Autonomous, var\"#s206\"}, <:Function} where var\"#s206\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","page":"CTBase API","title":"CTBase.:⋅","text":"⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#94#96\"{VectorField{NonAutonomous, var\"#s206\"}, <:Function} where var\"#s206\"<:VariableDependence\n\n\nLie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case\n\nExample\n\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n\n\nLie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n\n\nLie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Tuple{VectorField, Function}","page":"CTBase API","title":"CTBase.Lie","text":"Lie(X::VectorField, f::Function) -> Function\n\n\nLie derivative of a scalar function along a vector field.\n\nExample\n\njulia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case\n\nExample\n\njulia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Lie","text":"Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n\n\nLie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case\n\nExample\n\njulia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::Function, dependences::DataType...) -> Function\n\n\nReturn the Lift of a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{Function}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::Function; autonomous, variable) -> Function\n\n\nReturn the Lift of a function. Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Lift-Tuple{VectorField}","page":"CTBase API","title":"CTBase.Lift","text":"Lift(X::VectorField) -> HamiltonianLift\n\n\nReturn the HamiltonianLift of a VectorField.\n\nExample\n\njulia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{Vararg{DataType}}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following argument:\n\ndependencies: either Autonomous or NonAutonomous. Default is Autonomous. And either NonFixed or Fixed. Default is Fixed.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Model-Tuple{}","page":"CTBase API","title":"CTBase.Model","text":"Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\nautonomous: either true or false. Default is true.\nvariable: either true or false. Default is false.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Tuple{Function, Function}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n\n\nPoisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable.\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case\n\nExample\n\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n\n\nPoisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n\n\nPoisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.Poisson","text":"Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n\n\nPoisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g)\n\nExample\n\njulia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.__OCPModel-Tuple","page":"CTBase API","title":"CTBase.__OCPModel","text":"__OCPModel(args...; kwargs...) -> OptimalControlModel\n\n\nRedirection to Model to avoid confusion with other functions Model from other packages if imported. This function is used by @def.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. Throw an error if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.boundary_constraints!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.boundary_constraints!","text":"boundary_constraints!(\n    sol::OptimalControlSolution,\n    boundary_constraints::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.boundary_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.boundary_constraints","text":"boundary_constraints(\n    sol::OptimalControlSolution\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the boundary constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol;\n    rg,\n    f,\n    lb,\n    ub,\n    val,\n    label\n)\n\n\nAdd a constraint to an optimal control problem, denoted ocp.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe initial and final times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nYou can add an :initial, :final, :control, :state or :variable box constraint (whole range). \n\nRange constraint on the state, control or variable\n\nYou can add an :initial, :final, :control, :state or :variable box constraint on a range of it, that is only on some components. If not range is specified, then the constraint is on the whole range. We denote by x, u and v respectively the state, control and variable. We denote by n, m and q respectively the dimension of the state, control and variable. The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\n\nExamples\n\njulia> constraint!(ocp, :initial; rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :initial; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :control; rg=1, lb=0, ub=2)\njulia> constraint!(ocp, :state; rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :variable; rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ])                 # [ 0, 0, 0 ] ≤ x(t0),                          dim(x) = 3\njulia> constraint!(ocp, :initial; lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ]) # [ 0, 0, 0 ] ≤ x(t0) ≤ [ 1, 2, 1 ],            dim(x) = 3\njulia> constraint!(ocp, :final; lb=-1, ub=1)                      #          -1 ≤ x(tf) ≤ 1,                      dim(x) = 1\njulia> constraint!(ocp, :control; lb=0, ub=2)                     #           0 ≤ u(t)  ≤ 2,        t ∈ [t0, tf], dim(u) = 1\njulia> constraint!(ocp, :state; lb=[ 0, 0 ], ub=[ 1, 2 ])         #    [ 0, 0 ] ≤ x(t)  ≤ [ 1, 2 ], t ∈ [t0, tf], dim(x) = 2\njulia> constraint!(ocp, :variable; lb=[ 0, 0 ], ub=[ 1, 2 ])      #    [ 0, 0 ] ≤    v  ≤ [ 1, 2 ],               dim(v) = 2\n\nFunctional constraint\n\nYou can add a :boundary, :control, :state, :mixed or :variable box functional constraint.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf) -> x0[3]+xf[2], lb=0, ub=1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary; f = (x0, xf, v) -> x0[3]+xf[2]*v[1], lb=0, ub=1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control; f = u -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = x -> x-1, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u) -> x[1]-u, lb=0, ub=1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control; f = (t, u) -> 2u, lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x) -> t * x, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u) -> x[1]-u, lb=0, ub=1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (u, v) -> 2u * v[1], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (x, v) -> x * v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (x, u, v) -> x[1]-v[2]*u, lb=0, ub=1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control; f = (t, u, v) -> 2u+v[2], lb=0, ub=1)\njulia> constraint!(ocp, :state; f = (t, x, v) -> x-t*v[1], lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed; f = (t, x, u, v) -> x[1]*v[2]-u, lb=0, ub=1)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraint_type-NTuple{7, Any}","page":"CTBase API","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...) Expressions like u(t0) where u is the control and t0 the initial time return :other.\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, 1)\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, 1)\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, 1)\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, 1)\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, 2)\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n:variable_fun\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n:variable_fun\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control!","page":"CTBase API","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nnote: Note\nYou must use control! only once to set the control dimension.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.control-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.control","text":"control(sol::OptimalControlSolution) -> Function\n\n\nReturn the control (function of time) of the optimal control solution or nothing.\n\njulia> t0 = time_grid(sol)[1]\njulia> u  = control(sol)\njulia> u0 = u(t0) # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control_components_names-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.control_components_names","text":"control_components_names(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the control of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control_components_names-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.control_components_names","text":"control_components_names(sol::OptimalControlSolution)\n\n\nReturn the names of the components of the control of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control_constraints!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.control_constraints!","text":"control_constraints!(\n    sol::OptimalControlSolution,\n    control_constraints::Function\n)\n\n\nSet the control constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.control_constraints","text":"control_constraints(sol::OptimalControlSolution) -> Function\n\n\nReturn the control constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control_dimension-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.control_dimension","text":"control_dimension(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimention of the control of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control_dimension-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.control_dimension","text":"control_dimension(sol::OptimalControlSolution) -> Integer\n\n\nReturn the dimension of the control of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control_discretized-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.control_discretized","text":"control_discretized(sol::OptimalControlSolution) -> Any\n\n\nReturn the control values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> u  = control_discretized(sol)\njulia> u0 = u[1] # control at initial time\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control_name-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.control_name","text":"control_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the control of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.control_name-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.control_name","text":"control_name(sol::OptimalControlSolution) -> String\n\n\nReturn the name of the control of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.costate!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.costate!","text":"costate!(sol::OptimalControlSolution, costate::Function)\n\n\nSet the costate.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.costate-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.costate","text":"costate(sol::OptimalControlSolution) -> Function\n\n\nReturn the costate of the optimal control solution or nothing.\n\njulia> t0 = time_grid(sol)[1]\njulia> p  = costate(sol)\njulia> p0 = p(t0)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.costate_discretized-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.costate_discretized","text":"costate_discretized(sol::OptimalControlSolution) -> Any\n\n\nReturn the costate values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> p  = costate_discretized(sol)\njulia> p0 = p[1] # costate at initial time\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.criterion-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.criterion","text":"criterion(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Symbol}\n\n\nReturn the criterion (:min or :max) of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ct_repl-Tuple{}","page":"CTBase API","title":"CTBase.ct_repl","text":"ct_repl(; debug, verbose)\n\n\nCreate a ct REPL.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ct_repl_update_model-Tuple{Expr}","page":"CTBase API","title":"CTBase.ct_repl_update_model","text":"ct_repl_update_model(e::Expr)\n\n\nUpdate the model adding the expression e. It must be public since in the ct repl, this function  is quoted each time an expression is parsed and is valid. \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x::Real; backend) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctgradient-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctgradient","text":"ctgradient(X::VectorField, x) -> Any\n\n\nReturn the gradient of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctindices-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"CTBase API","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{Function, Real}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x::Real; backend) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctjacobian-Tuple{VectorField, Any}","page":"CTBase API","title":"CTBase.ctjacobian","text":"ctjacobian(X::VectorField, x) -> Any\n\n\nReturn the Jacobian of X at x.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.ctupperscripts-Tuple{Integer}","page":"CTBase API","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_boundary_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_boundary_constraints","text":"dim_boundary_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of the boundary constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_control_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_control_constraints","text":"dim_control_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear control constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_control_range-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_control_range","text":"dim_control_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on control (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_mixed_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_mixed_constraints","text":"dim_mixed_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear mixed constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_path_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_path_constraints","text":"dim_path_constraints(ocp::OptimalControlModel) -> Any\n\n\nReturn the dimension of nonlinear path (state + control + mixed) constraints (nothing if one of them is not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_state_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_state_constraints","text":"dim_state_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear state constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_state_range-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_state_range","text":"dim_state_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on state (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_variable_constraints-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_variable_constraints","text":"dim_variable_constraints(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of nonlinear variable constraints (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dim_variable_range-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dim_variable_range","text":"dim_variable_range(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of range constraints on variable (nothing if not knonw). Information is updated after nlp_constraints! is called.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.dynamics!","text":"dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n\n\nSet the dynamics.\n\nnote: Note\nYou can use dynamics! only once to define the dynamics.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> dynamics!(ocp, f)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.dynamics-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.dynamics","text":"dynamics(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Dynamics}\n\n\nReturn the dynamics of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.final_time-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.final_time","text":"final_time(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Index, Real}\n\n\nReturn the final time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.final_time_name-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.final_time_name","text":"final_time_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the final time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.final_time_name-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.final_time_name","text":"final_time_name(sol::OptimalControlSolution) -> String\n\n\nReturn the name of final time of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"CTBase API","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_free_final_time-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_free_final_time","text":"has_free_final_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free final time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_free_initial_time-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_free_initial_time","text":"has_free_initial_time(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with free initial time.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_lagrange_cost-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_lagrange_cost","text":"has_lagrange_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with lagrange cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.has_mayer_cost-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.has_mayer_cost","text":"has_mayer_cost(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined with mayer cost.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.infos!-Tuple{OptimalControlSolution, Dict{Symbol, Any}}","page":"CTBase API","title":"CTBase.infos!","text":"infos!(\n    sol::OptimalControlSolution,\n    infos::Dict{Symbol, Any}\n)\n\n\nSet the additional infos.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.infos-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.infos","text":"infos(sol::OptimalControlSolution) -> Dict{Symbol, Any}\n\n\nReturn a dictionary of additional infos depending on the solver or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.initial_time-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.initial_time","text":"initial_time(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Index, Real}\n\n\nReturn the initial time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.initial_time_name-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.initial_time_name","text":"initial_time_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the initial time of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.initial_time_name-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.initial_time_name","text":"initial_time_name(sol::OptimalControlSolution) -> String\n\n\nReturn the name of the initial time of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_autonomous-Tuple{OptimalControlModel{Autonomous}}","page":"CTBase API","title":"CTBase.is_autonomous","text":"is_autonomous(ocp::OptimalControlModel{Autonomous}) -> Bool\n\n\nReturn true if the model is autonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_fixed-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","page":"CTBase API","title":"CTBase.is_fixed","text":"is_fixed(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n) -> Bool\n\n\nReturn true if the model is fixed (= has no variable).\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_max-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_max","text":"is_max(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_min-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_min","text":"is_min(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_dependent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_time_dependent","text":"is_time_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_time_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_time_independent","text":"is_time_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_variable_dependent","text":"is_variable_dependent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.is_variable_independent","text":"is_variable_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable independent.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.iterations!-Tuple{OptimalControlSolution, Int64}","page":"CTBase API","title":"CTBase.iterations!","text":"iterations!(sol::OptimalControlSolution, iterations::Int64)\n\n\nSet the number of iterations.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.iterations-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.iterations","text":"iterations(sol::OptimalControlSolution) -> Int64\n\n\nReturn the number of iterations (if solved by an iterative method) of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.lagrange-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.lagrange","text":"lagrange(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Lagrange}\n\n\nReturn the Lagrange part of the cost of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mayer-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.mayer","text":"mayer(ocp::OptimalControlModel) -> Union{Nothing, Mayer}\n\n\nReturn the Mayer part of the cost of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.message!-Tuple{OptimalControlSolution, String}","page":"CTBase API","title":"CTBase.message!","text":"message!(sol::OptimalControlSolution, message::String)\n\n\nSet the message of stopping.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.message-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.message","text":"message(sol::OptimalControlSolution) -> String\n\n\nReturn the message associated to the stopping criterion of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mixed_constraints!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.mixed_constraints!","text":"mixed_constraints!(\n    sol::OptimalControlSolution,\n    mixed_constraints::Function\n)\n\n\nSet the mixed state/control constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mixed_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mixed_constraints","text":"mixed_constraints(sol::OptimalControlSolution) -> Function\n\n\nReturn the mixed state-control constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.model_expression-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.model_expression","text":"model_expression(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Expr}\n\n\nReturn the model expression of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_boundary_constraints!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.mult_boundary_constraints!","text":"mult_boundary_constraints!(\n    sol::OptimalControlSolution,\n    mult_boundary_constraints::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the multipliers to the boundary constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_boundary_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_boundary_constraints","text":"mult_boundary_constraints(\n    sol::OptimalControlSolution\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the multipliers to the boundary constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_control_box_lower!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.mult_control_box_lower!","text":"mult_control_box_lower!(\n    sol::OptimalControlSolution,\n    mult_control_box_lower::Function\n)\n\n\nSet the multipliers to the control lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_control_box_lower-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_control_box_lower","text":"mult_control_box_lower(\n    sol::OptimalControlSolution\n) -> Function\n\n\nReturn the multipliers to the control lower bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_control_box_upper!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.mult_control_box_upper!","text":"mult_control_box_upper!(\n    sol::OptimalControlSolution,\n    mult_control_box_upper::Function\n)\n\n\nSet the multipliers to the control upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_control_box_upper-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_control_box_upper","text":"mult_control_box_upper(\n    sol::OptimalControlSolution\n) -> Function\n\n\nReturn the multipliers to the control upper bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_control_constraints!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.mult_control_constraints!","text":"mult_control_constraints!(\n    sol::OptimalControlSolution,\n    mult_control_constraints::Function\n)\n\n\nSet the multipliers to the control constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_control_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_control_constraints","text":"mult_control_constraints(\n    sol::OptimalControlSolution\n) -> Function\n\n\nReturn the multipliers to the control constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_mixed_constraints!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.mult_mixed_constraints!","text":"mult_mixed_constraints!(\n    sol::OptimalControlSolution,\n    mult_mixed_constraints::Function\n)\n\n\nSet the multipliers to the mixed state/control constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_mixed_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_mixed_constraints","text":"mult_mixed_constraints(\n    sol::OptimalControlSolution\n) -> Function\n\n\nReturn the multipliers to the mixed state-control constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_state_box_lower!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.mult_state_box_lower!","text":"mult_state_box_lower!(\n    sol::OptimalControlSolution,\n    mult_state_box_lower::Function\n)\n\n\nSet the multipliers to the state lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_state_box_lower-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_state_box_lower","text":"mult_state_box_lower(\n    sol::OptimalControlSolution\n) -> Function\n\n\nReturn the multipliers to the state lower bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_state_box_upper!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.mult_state_box_upper!","text":"mult_state_box_upper!(\n    sol::OptimalControlSolution,\n    mult_state_box_upper::Function\n)\n\n\nSet the multipliers to the state upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_state_box_upper-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_state_box_upper","text":"mult_state_box_upper(\n    sol::OptimalControlSolution\n) -> Function\n\n\nReturn the multipliers to the state upper bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_state_constraints!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.mult_state_constraints!","text":"mult_state_constraints!(\n    sol::OptimalControlSolution,\n    mult_state_constraints::Function\n)\n\n\nSet the multipliers to the state constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_state_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_state_constraints","text":"mult_state_constraints(\n    sol::OptimalControlSolution\n) -> Function\n\n\nReturn the multipliers to the state constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_variable_box_lower!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.mult_variable_box_lower!","text":"mult_variable_box_lower!(\n    sol::OptimalControlSolution,\n    mult_variable_box_lower::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the multipliers to the variable lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_variable_box_lower-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_variable_box_lower","text":"mult_variable_box_lower(\n    sol::OptimalControlSolution\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the multipliers to the variable lower bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_variable_box_upper!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.mult_variable_box_upper!","text":"mult_variable_box_upper!(\n    sol::OptimalControlSolution,\n    mult_variable_box_upper::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the multipliers to the variable upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_variable_box_upper-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_variable_box_upper","text":"mult_variable_box_upper(\n    sol::OptimalControlSolution\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the multipliers to the variable upper bounds of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_variable_constraints!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.mult_variable_constraints!","text":"mult_variable_constraints!(\n    sol::OptimalControlSolution,\n    mult_variable_constraints::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the multipliers to the variable constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.mult_variable_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.mult_variable_constraints","text":"mult_variable_constraints(\n    sol::OptimalControlSolution\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the multipliers to the variable constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.nlp_constraints!-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.nlp_constraints!","text":"nlp_constraints!(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Any, CTBase.var\"#ξ#41\", Vector{Real}}, Tuple{Any, CTBase.var\"#η#42\", Vector{Real}}, Tuple{Any, CTBase.var\"#ψ#43\", Vector{Real}}, Tuple{Any, CTBase.var\"#ϕ#44\", Vector{Real}}, Tuple{Any, CTBase.var\"#θ#45\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(θl, θ, θu) are variable constraints\n(ul, uind, uu) are control linear constraints of a subset of indices\n(xl, xind, xu) are state linear constraints of a subset of indices\n(vl, vind, vu) are variable linear constraints of a subset of indices\n\nand update information about constraints dimensions of  ocp.\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints!.\nFor a Fixed problem, dimensions associated with constraints on the variable are set to zero.\n\nExample\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints!(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"CTBase API","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nYou can use objective! only once to define the objective.The state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.objective-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.objective","text":"objective(sol::OptimalControlSolution) -> Real\n\n\nReturn the objective value of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.remove-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"CTBase API","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"CTBase API","title":"CTBase.remove_constraint!","text":"remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"CTBase API","title":"CTBase.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state!","page":"CTBase API","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nnote: Note\nYou must use state! only once to set the state dimension.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.state-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.state","text":"state(sol::OptimalControlSolution) -> Function\n\n\nReturn the state (function of time) of the optimal control solution or nothing.\n\njulia> t0 = time_grid(sol)[1]\njulia> x  = state(sol)\njulia> x0 = x(t0)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state_components_names-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.state_components_names","text":"state_components_names(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the state of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state_components_names-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.state_components_names","text":"state_components_names(sol::OptimalControlSolution)\n\n\nReturn the names of the components of the state of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state_constraints!-Tuple{OptimalControlSolution, Function}","page":"CTBase API","title":"CTBase.state_constraints!","text":"state_constraints!(\n    sol::OptimalControlSolution,\n    state_constraints::Function\n)\n\n\nSet the state constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.state_constraints","text":"state_constraints(sol::OptimalControlSolution) -> Function\n\n\nReturn the state constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state_dimension-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.state_dimension","text":"state_dimension(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of the state of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state_dimension-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.state_dimension","text":"state_dimension(sol::OptimalControlSolution) -> Integer\n\n\nReturn the dimension of the state of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state_discretized-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.state_discretized","text":"state_discretized(sol::OptimalControlSolution) -> Any\n\n\nReturn the state values at times time_grid(sol) of the optimal control solution or nothing.\n\njulia> x  = state_discretized(sol)\njulia> x0 = x[1] # state at initial time\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state_name-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.state_name","text":"state_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the state of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.state_name-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.state_name","text":"state_name(sol::OptimalControlSolution) -> String\n\n\nReturn the name of the state of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.stopping!-Tuple{OptimalControlSolution, Symbol}","page":"CTBase API","title":"CTBase.stopping!","text":"stopping!(sol::OptimalControlSolution, stopping::Symbol)\n\n\nSet the stopping criterion.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.stopping-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.stopping","text":"stopping(sol::OptimalControlSolution) -> Symbol\n\n\nReturn the stopping criterion (a Symbol) of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.success!-Tuple{OptimalControlSolution, Bool}","page":"CTBase API","title":"CTBase.success!","text":"success!(sol::OptimalControlSolution, success::Bool)\n\n\nSet the success.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.success-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.success","text":"success(sol::OptimalControlSolution) -> Bool\n\n\nReturn the true if the solver has finished successfully of false if not, or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.time!-Union{Tuple{OptimalControlModel{<:TimeDependence, VT}}, Tuple{VT}} where VT","page":"CTBase API","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, VT};\n    t0,\n    tf,\n    ind0,\n    indf,\n    name\n)\n\n\nSet the initial and final times. We denote by t0 the initial time and tf the final time. The optimal control problem is denoted ocp. When a time is free, then one must provide the corresponding index of the ocp variable.\n\nnote: Note\nYou must use time! only once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, t0=0,   tf=1  ) # Fixed t0 and fixed tf\njulia> time!(ocp, t0=0,   indf=2) # Fixed t0 and free  tf\njulia> time!(ocp, ind0=2, tf=1  ) # Free  t0 and fixed tf\njulia> time!(ocp, ind0=2, indf=3) # Free  t0 and free  tf\n\nWhen you plot a solution of an optimal control problem, the name of the time variable appears. By default, the name is \"t\". Consider you want to set the name of the time variable to \"s\".\n\njulia> time!(ocp, t0=0, tf=1, name=\"s\") # name is a String\n# or\njulia> time!(ocp, t0=0, tf=1, name=:s ) # name is a Symbol  \n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.time_grid!-Tuple{OptimalControlSolution, Union{StepRangeLen, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.time_grid!","text":"time_grid!(\n    sol::OptimalControlSolution,\n    time_grid::Union{StepRangeLen, AbstractVector{<:Real}}\n)\n\n\nSet the time grid.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.time_grid-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.time_grid","text":"time_grid(\n    sol::OptimalControlSolution\n) -> Union{StepRangeLen, AbstractVector{<:Real}}\n\n\nReturn the time grid of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.time_name-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.time_name","text":"time_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the time component of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.time_name-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.time_name","text":"time_name(sol::OptimalControlSolution) -> String\n\n\nReturn the name of the time component of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable!","page":"CTBase API","title":"CTBase.variable!","text":"variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nnote: Note\nYou can use variable! once to set the variable dimension when the model is NonFixed.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-ctbase.html#CTBase.variable-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.variable","text":"variable(\n    sol::OptimalControlSolution\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable of the optimal control solution or nothing.\n\njulia> v  = variable(sol)\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable_components_names-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.variable_components_names","text":"variable_components_names(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Vector{String}}\n\n\nReturn the names of the components of the variable of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable_components_names-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.variable_components_names","text":"variable_components_names(sol::OptimalControlSolution)\n\n\nReturn the names of the components of the variable of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable_constraints!-Tuple{OptimalControlSolution, Union{Real, AbstractVector{<:Real}}}","page":"CTBase API","title":"CTBase.variable_constraints!","text":"variable_constraints!(\n    sol::OptimalControlSolution,\n    variable_constraints::Union{Real, AbstractVector{<:Real}}\n)\n\n\nSet the variable constraints.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable_constraints-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.variable_constraints","text":"variable_constraints(\n    sol::OptimalControlSolution\n) -> Union{Real, AbstractVector{<:Real}}\n\n\nReturn the variable constraints of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable_dimension-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.variable_dimension","text":"variable_dimension(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Integer}\n\n\nReturn the dimension of the variable of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable_dimension-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.variable_dimension","text":"variable_dimension(sol::OptimalControlSolution) -> Integer\n\n\nReturn the dimension of the variable of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable_name-Tuple{OptimalControlModel}","page":"CTBase API","title":"CTBase.variable_name","text":"variable_name(\n    ocp::OptimalControlModel\n) -> Union{Nothing, String}\n\n\nReturn the name of the variable of the optimal control problem or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.variable_name-Tuple{OptimalControlSolution}","page":"CTBase API","title":"CTBase.variable_name","text":"variable_name(sol::OptimalControlSolution) -> String\n\n\nReturn the name of the variable of the optimal control solution or nothing.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.∂ₜ-Tuple{Any}","page":"CTBase API","title":"CTBase.∂ₜ","text":"∂ₜ(f) -> CTBase.var\"#99#101\"\n\n\nPartial derivative wrt time of a function.\n\nExample\n\njulia> ∂ₜ((t,x) -> t*x)(0,8)\n8\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr, Any, Any}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Poisson brackets\n\nExample\n\njulia> H0 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7]) autonomous=true variable=false\n#\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false variable=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) autonomous=true variable=true\n#\njulia> H0 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2) autonomous=false variable=true\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr, Any}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> H0 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2)\njulia> H1 = (t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7]) autonomous=false\n#\njulia> H0 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v)\njulia> H1 = (x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2) variable=true\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@Lie-Tuple{Expr}","page":"CTBase API","title":"CTBase.@Lie","text":"Macros for Lie and Poisson brackets\n\nExample\n\njulia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\n#\njulia> F0 = VectorField((t, x) -> [t+x[1], x[2], (1-x[3])], autonomous=false)\njulia> F1 = VectorField((t, x) -> [t, -x[3], x[2]], autonomous=false)\njulia> @Lie [F0, F1](1, [1, 2, 3])\n#\njulia> F0 = VectorField((x, v) -> [x[1]+v, x[2], (1-x[3])], variable=true)\njulia> F1 = VectorField((x, v) -> [0, -x[3]-v, x[2]], variable=true)\njulia> @Lie [F0, F1]([1, 2, 3], 2)\n#\njulia> F0 = VectorField((t, x, v) -> [t+x[1]+v, x[2], (1-x[3])], autonomous=false, variable=true)\njulia> F1 = VectorField((t, x, v) -> [t, -x[3]-v, x[2]], autonomous=false, variable=true)\njulia> @Lie [F0, F1](1, [1, 2, 3], 2)\n#\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7])\n3.0\n#\njulia> H0 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[1]^2), autonomous=false)\njulia> H1 = Hamiltonian((t, x, p) -> 0.5*(x[1]^2+x[2]^2+p[2]^2), autonomous=false)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7])\n#\njulia> H0 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), variable=true)\njulia> H1 = Hamiltonian((x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), variable=true)\njulia> @Lie {H0, H1}([1, 2, 3], [1, 0, 7], 2)\n#\njulia> H0 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[1]^2+v), autonomous=false, variable=true)\njulia> H1 = Hamiltonian((t, x, p, v) -> 0.5*(x[1]^2+x[2]^2+p[2]^2+v), autonomous=false, variable=true)\njulia> @Lie {H0, H1}(1, [1, 2, 3], [1, 0, 7], 2)\n#\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.@def-Tuple{Any}","page":"CTBase API","title":"CTBase.@def","text":"Define an optimal control problem. One pass parsing of the definition. Can be used writing either ocp = @def begin ... end or @def ocp begin ... end. In the second case, setting log to true will display the parsing steps.\n\nExample\n\nocp = @def begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend\n\n@def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend true # final boolean to show parsing log\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html","page":"CTBase API","title":"CTBase API","text":"","category":"page"}]
}
