var documenterSearchIndex = {"docs":
[{"location":"collocation.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"collocation.html#Index","page":"Solution","title":"Index","text":"Pages   = [\"collocation.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"collocation.html#Documentation","page":"Solution","title":"Documentation","text":"","category":"section"},{"location":"docp.html#DOCP","page":"DOCP","title":"DOCP","text":"","category":"section"},{"location":"docp.html#Index","page":"DOCP","title":"Index","text":"Pages   = [\"docp.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"docp.html#Documentation","page":"DOCP","title":"Documentation","text":"","category":"section"},{"location":"collocation_variables.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"collocation_variables.html#Index","page":"Solution","title":"Index","text":"Pages   = [\"collocation_variables.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"collocation_variables.html#Documentation","page":"Solution","title":"Documentation","text":"","category":"section"},{"location":"collocation_variables.html#CTDirect.DOCP_initial_guess-Tuple{CTDirect.DOCP, CTModels.InitialGuess.OptimalControlInitialGuess}","page":"Solution","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(\n    docp::CTDirect.DOCP,\n    init::CTModels.InitialGuess.OptimalControlInitialGuess\n) -> Vector{Float64}\n\n\nBuild an initial guess vector for the discretized OCP.\n\nArguments\n\ndocp::DOCP: The discretized OCP.\ninit::CTModels.Init: Initialization settings (default: CTModels.Init()).\n\nReturns\n\nNLP_X::Vector{Float64}: Initial guess vector.\n\nExample\n\njulia> DOCP_initial_guess(docp)\n[0.1, 0.1, …]\n\n\n\n\n\n","category":"method"},{"location":"collocation_variables.html#CTDirect.build_bounds_block-Tuple{Any, Any, Any}","page":"Solution","title":"CTDirect.build_bounds_block","text":"build_bounds_block(\n    dim_var,\n    dim_box,\n    box_triplet\n) -> Tuple{Any, Any}\n\n\nBuild lower and upper bound vectors for state, control, or optimization variables.\n\nArguments\n\ndim_var::Int: Variable dimension.\ndim_box::Int: Number of box constraints.\nbox_triplet: Triplet defining box constraints.\n\nReturns\n\n(x_lb, x_ub)::Tuple{Vector{Float64},Vector{Float64}}: Lower and upper bounds.\n\nExample\n\njulia> build_bounds_block(3, 1, ([0.0], [2], [1.0]))\n([-Inf, 0.0, -Inf], [Inf, 1.0, Inf])\n\n\n\n\n\n","category":"method"},{"location":"collocation_variables.html#CTDirect.variables_bounds!-Tuple{CTDirect.DOCP}","page":"Solution","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild lower and upper bounds vectors for the variable box constraints of a DOCP.\n\nArguments\n\ndocp::DOCP: The discretized OCP.\n\nReturns\n\n(var_l, var_u)::Tuple{Vector{Float64},Vector{Float64}}: Lower and upper bounds for variables.\n\nExample\n\njulia> variables_bounds!(docp)\n([-Inf, …], [Inf, …])\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"collocation_core.html#Index","page":"Solution","title":"Index","text":"Pages   = [\"collocation_core.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"collocation_core.html#Documentation","page":"Solution","title":"Documentation","text":"","category":"section"},{"location":"collocation_core.html#CTDirect.DOCP","page":"Solution","title":"CTDirect.DOCP","text":"mutable struct DOCP{D<:CTDirect.Discretization, O<:CTModels.OCP.Model}\n\nStruct representing a discretized optimal control problem (DOCP).\n\nFields\n\ndiscretization::D: The discretization scheme.\nocp::O: The original OCP model.\nflags::DOCPFlags: Boolean flags describing problem structure.\ndims::DOCPdims: Problem dimensions.\ntime::DOCPtime: Time discretization.\nbounds::DOCPbounds: Variable and constraint bounds.\ndim_NLP_variables::Int: Number of NLP variables.\ndim_NLP_constraints::Int: Number of NLP constraints.\n\nExample\n\njulia> DOCP(ocp, nlp_model_backend)\nDOCP{...}(...)\n\n\n\n\n\n","category":"type"},{"location":"collocation_core.html#CTDirect.DOCPFlags","page":"Solution","title":"CTDirect.DOCPFlags","text":"struct DOCPFlags\n\nInternal struct holding boolean flags that characterize properties of the  discretized optimal control problem (DOCP).\n\nFields\n\nfreet0::Bool: Whether the OCP has a free initial time.\nfreetf::Bool: Whether the OCP has a free final time.\nlagrange::Bool: Whether the OCP includes a Lagrange cost.\nmayer::Bool: Whether the OCP includes a Mayer cost.\nmax::Bool: Whether the OCP is a maximization problem.\n\nExample\n\njulia> DOCPFlags(true, false, true, true, false)\nDOCPFlags(true, false, true, true, false)\n\n\n\n\n\n","category":"type"},{"location":"collocation_core.html#CTDirect.DOCPFlags-Tuple{CTModels.OCP.Model}","page":"Solution","title":"CTDirect.DOCPFlags","text":"DOCPFlags(ocp::CTModels.OCP.Model) -> CTDirect.DOCPFlags\n\n\nConstruct a DOCPFlags struct from an OCP model.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem model.\n\nReturns\n\nDOCPFlags: A struct encoding the problem’s boolean properties.\n\nExample\n\njulia> DOCPFlags(ocp)\nDOCPFlags(false, true, true, false, false)\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#CTDirect.DOCPbounds","page":"Solution","title":"CTDirect.DOCPbounds","text":"struct DOCPbounds\n\nInternal struct holding variable and constraint bounds for a DOCP.\n\nFields\n\nvar_l::Vector{Float64}: Lower bounds for NLP variables.\nvar_u::Vector{Float64}: Upper bounds for NLP variables.\ncon_l::Vector{Float64}: Lower bounds for NLP constraints.\ncon_u::Vector{Float64}: Upper bounds for NLP constraints.\n\nExample\n\njulia> DOCPbounds([-1.0, -2.0], [1.0, 2.0], [0.0], [0.0])\nDOCPbounds([-1.0, -2.0], [1.0, 2.0], [0.0], [0.0])\n\n\n\n\n\n","category":"type"},{"location":"collocation_core.html#CTDirect.DOCPdims","page":"Solution","title":"CTDirect.DOCPdims","text":"struct DOCPdims\n\nInternal struct holding problem dimensions for a DOCP.\n\nFields\n\nNLP_x::Int: State dimension\nNLP_u::Int: Control dimension.\nNLP_v::Int: Variable dimension.\npath_cons::Int: Path constraints dimension.\nboundary_cons::Int: Boundary constraints dimension.\n\nExample\n\njulia> DOCPdims(4, 2, 1, 3, 2, 1)\nDOCPdims(4, 2, 1, 3, 2, 1)\n\n\n\n\n\n","category":"type"},{"location":"collocation_core.html#CTDirect.DOCPdims-Tuple{CTModels.OCP.Model}","page":"Solution","title":"CTDirect.DOCPdims","text":"DOCPdims(ocp::CTModels.OCP.Model) -> CTDirect.DOCPdims\n\n\nConstruct a DOCPdims struct from an OCP model.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem model.\n\nReturns\n\nDOCPdims: A struct containing the problem dimensions.\n\nExample\n\njulia> DOCPdims(ocp)\nDOCPdims(4, 2, 1, 4, 2, 1)\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#CTDirect.DOCPtime","page":"Solution","title":"CTDirect.DOCPtime","text":"struct DOCPtime\n\nInternal struct holding time grid information for a DOCP.\n\nFields\n\nsteps::Int: Number of time steps.\nnormalized_grid::Vector{Float64}: Normalized time grid in [0,1].\nfixed_grid::Vector{Float64}: Fixed time grid in [t0, tf].\n\nExample\n\njulia> DOCPtime(10, collect(0:0.1:1), collect(0.0:0.1:1.0))\nDOCPtime(10, [0.0, 0.1, …, 1.0], [0.0, 0.1, …, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"collocation_core.html#CTDirect.DOCPtime-Tuple{CTModels.OCP.Model, Int64, Any}","page":"Solution","title":"CTDirect.DOCPtime","text":"DOCPtime(\n    ocp::CTModels.OCP.Model,\n    grid_size::Int64,\n    time_grid\n) -> CTDirect.DOCPtime\n\n\nConstruct a DOCPtime struct from an OCP model.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem model.\ngrid_size::Int: Number of grid steps if no grid is provided.\ntime_grid: Custom time grid (or nothing to auto-generate).\n\nReturns\n\nDOCPtime: A struct encoding the time discretization.\n\nExample\n\njulia> DOCPtime(ocp, 10, nothing)\nDOCPtime(10, [0.0, 0.1, …, 1.0], [0.0, 0.1, …, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#CTDirect.build_OCP_solution-Tuple{CTDirect.DOCP, SolverCore.AbstractExecutionStats, Vararg{Any, 7}}","page":"Solution","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(\n    docp::CTDirect.DOCP,\n    nlp_solution::SolverCore.AbstractExecutionStats,\n    T,\n    objective,\n    iterations,\n    constraints_violation,\n    message,\n    status,\n    successful;\n    exa_getter\n) -> CTModels.OCP.Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, ModelType, CostateModelType, Float64, DualModelType, CTModels.OCP.SolverInfos{Any, Dict{Symbol, Any}}} where {TimeGridModelType<:Union{CTModels.OCP.TimeGridModel{LinRange{Float64, Int64}}, CTModels.OCP.TimeGridModel{Vector{Float64}}}, TimesModelType<:CTModels.OCP.TimesModel, StateModelType<:Union{CTModels.OCP.StateModelSolution{TS} where TS<:CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##0#_wrap_scalar_and_deepcopy##1\", CTModels.OCP.StateModelSolution{TS} where TS<:CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##2#_wrap_scalar_and_deepcopy##3\"}, ControlModelType<:Union{CTModels.OCP.ControlModelSolution{TS} where TS<:CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##0#_wrap_scalar_and_deepcopy##1\", CTModels.OCP.ControlModelSolution{TS} where TS<:CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##2#_wrap_scalar_and_deepcopy##3\"}, VariableModelType<:Union{CTModels.OCP.VariableModelSolution{Vector{Float64}}, CTModels.OCP.VariableModelSolution{Float64}}, ModelType<:(CTModels.OCP.Model{<:CTModels.OCP.TimeDependence, T} where T<:CTModels.OCP.TimesModel), CostateModelType<:Union{CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##0#_wrap_scalar_and_deepcopy##1\", CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##2#_wrap_scalar_and_deepcopy##3\"}, DualModelType<:(CTModels.OCP.DualModel{PC_Dual, BC_Dual, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, Vector{Float64}, Vector{Float64}} where {PC_Dual<:Union{CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##0#_wrap_scalar_and_deepcopy##1\", CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##2#_wrap_scalar_and_deepcopy##3\"}, BC_Dual<:Union{Nothing, Vector{Float64}}, SC_LB_Dual<:Union{CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##0#_wrap_scalar_and_deepcopy##1\", CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##2#_wrap_scalar_and_deepcopy##3\"}, SC_UB_Dual<:Union{CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##0#_wrap_scalar_and_deepcopy##1\", CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##2#_wrap_scalar_and_deepcopy##3\"}, CC_LB_Dual<:Union{CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##0#_wrap_scalar_and_deepcopy##1\", CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##2#_wrap_scalar_and_deepcopy##3\"}, CC_UB_Dual<:Union{CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##0#_wrap_scalar_and_deepcopy##1\", CTModels.OCP.var\"#_wrap_scalar_and_deepcopy##2#_wrap_scalar_and_deepcopy##3\"}})}\n\n\nBuild an OCP functional solution from a DOCP discrete solution given as a SolverCore.AbstractExecutionStats object.\n\nArguments\n\ndocp: The discretized optimal control problem (DOCP).\nnlp_solution: A solver execution statistics object.\n\nReturns\n\nsolution::CTModels.Solution: A functional OCP solution containing trajectories, multipliers, and solver information.\n\nExample\n\njulia> build_OCP_solution(docp, nlp_solution)\nCTModels.Solution(...)\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#CTDirect.disc_model-Tuple{CTDirect.DOCP}","page":"Solution","title":"CTDirect.disc_model","text":"disc_model(docp::CTDirect.DOCP) -> CTDirect.Discretization\n\n\nReturn the discretization model associated with a given discretized optimal control problem (DOCP).\n\nArguments\n\ndocp::DOCP: The discretized optimal control problem.\n\nReturns\n\ndiscretization::Any: The discretization model stored in docp.\n\nExample\n\njulia> disc_model(docp)\nDiscretizationModel(...)\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#CTDirect.get_time_grid-Tuple{Any, CTDirect.DOCP}","page":"Solution","title":"CTDirect.get_time_grid","text":"get_time_grid(xu, docp::CTDirect.DOCP) -> Any\n\n\nReturn the time grid for problems with free initial or final times. Note that this function can be called during optimization, not just for postprocessing\n\nArguments\n\nxu: Vector of NLP decision variables.\ndocp::DOCP: The discretized OCP.\n\nReturns\n\ngrid::Vector{Float64}: Time grid corresponding to current NLP variables.\n\nExample\n\njulia> get_time_grid(xu, docp)\n[0.0, 0.1, …, 1.0]\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#CTDirect.get_time_grid_exa-Tuple{SolverCore.AbstractExecutionStats, CTDirect.DOCP, Any}","page":"Solution","title":"CTDirect.get_time_grid_exa","text":"get_time_grid_exa(\n    nlp_solution::SolverCore.AbstractExecutionStats,\n    docp::CTDirect.DOCP,\n    exa_getter\n) -> Vector{Float64}\n\n\nRetrieve the time grid from the given DOCP solution.\n\nArguments\n\nnlp_solution: The DOCP solution.\ndocp: The DOCP.\n\nReturns\n\n::Vector{Float64}: The time grid.\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#CTDirect.is_empty-Tuple{Any}","page":"Solution","title":"CTDirect.is_empty","text":"is_empty(t) -> Any\n\n\nCheck whether a collection t is empty or not defined.\n\nArguments\n\nt: Any object that may be nothing or support length.\n\nReturns\n\n::Bool: true if t is nothing or has length zero, otherwise false.\n\nExample\n\njulia> is_empty([])\ntrue\n\njulia> is_empty([1, 2, 3])\nfalse\n\njulia> is_empty(nothing)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#CTDirect.is_solvable-Tuple{Any}","page":"Solution","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by solve.\n\nArguments\n\nocp: The OCP model.\n\nReturns\n\nsolvable::Bool: Always returns true in the current implementation.\n\nExample\n\njulia> is_solvable(ocp)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"collocation_core.html#CTDirect.ocp_model-Tuple{CTDirect.DOCP}","page":"Solution","title":"CTDirect.ocp_model","text":"ocp_model(docp::CTDirect.DOCP) -> CTModels.OCP.Model\n\n\nReturn the continuous-time optimal control problem (OCP) model associated with a given discretized optimal control problem (DOCP).\n\nArguments\n\ndocp::DOCP: The discretized optimal control problem.\n\nReturns\n\nocp::Any: The underlying OCP model stored in docp.\n\nExample\n\njulia> ocp_model(docp)\nOCPModel(...)\n\n\n\n\n\n","category":"method"},{"location":"collocation_functions.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"collocation_functions.html#Index","page":"Solution","title":"Index","text":"Pages   = [\"collocation_functions.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"collocation_functions.html#Documentation","page":"Solution","title":"Documentation","text":"","category":"section"},{"location":"collocation_functions.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, CTDirect.DOCP}","page":"Solution","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the nonlinear constraints of a DOCP.\n\nThe constraints are modeled as lb <= C(x) <= ub.\n\nArguments\n\nc: Preallocated constraint vector.\nxu: Vector of NLP decision variables.\ndocp::DOCP: The discretized OCP.\n\nReturns\n\nc: The filled constraint vector.\n\nExample\n\njulia> DOCP_constraints!(zeros(docp.dim_NLP_constraints), xu, docp)\n[0.0, 0.1, …]\n\n\n\n\n\n","category":"method"},{"location":"collocation_functions.html#CTDirect.DOCP_objective-Tuple{Any, CTDirect.DOCP}","page":"Solution","title":"CTDirect.DOCP_objective","text":"DOCP_objective(xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the objective value of a discretized OCP.\n\nArguments\n\nxu: Vector of NLP decision variables.\ndocp::DOCP: The discretized OCP.\n\nReturns\n\nobj::Float64: Objective function value.\n\nExample\n\njulia> DOCP_objective(xu, docp)\n12.34\n\n\n\n\n\n","category":"method"},{"location":"collocation_functions.html#CTDirect.constraints_bounds!-Tuple{CTDirect.DOCP}","page":"Solution","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild lower and upper bounds vectors for the nonlinear constraints of a DOCP.\n\nArguments\n\ndocp::DOCP: The discretized OCP.\n\nReturns\n\n(lb, ub)::Tuple{Vector{Float64},Vector{Float64}}: Lower and upper bounds.\n\nExample\n\njulia> constraints_bounds!(docp)\n([-1.0, …], [1.0, …])\n\n\n\n\n\n","category":"method"},{"location":"common.html#Common","page":"Common","title":"Common","text":"","category":"section"},{"location":"common.html#Index","page":"Common","title":"Index","text":"Pages   = [\"common.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"common.html#Documentation","page":"Common","title":"Documentation","text":"","category":"section"},{"location":"common.html#CTDirect.DOCP_Hessian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"Common","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian (to be implemented for each discretization scheme)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.DOCP_Jacobian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"Common","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints (to be implemented for each discretization scheme)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.add_nonzero_block!-NTuple{5, Any}","page":"Common","title":"CTDirect.add_nonzero_block!","text":"add_nonzero_block!(M, i_start, i_end, j_start, j_end; sym)\n\n\nAdd block of nonzeros elements to a sparsity pattern  Format: boolean matrix (M) or index vectors (Is, Js)  Includes a more compact method for single element case Option to add the symmetric block also (eg for Hessian) Note: independent from discretization scheme\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1), with convention u(tf) = U_N Vector output\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_OCP_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.get_OCP_state_at_time_step","text":"get_OCP_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Vector output\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_OCP_variable-Tuple{Any, CTDirect.DOCP}","page":"Common","title":"CTDirect.get_OCP_variable","text":"get_OCP_variable(xu, docp::CTDirect.DOCP) -> Any\n\n\nRetrieve optimization variables from the NLP variables. Convention: stored at the end, hence not dependent on the discretization method Vector output\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_stagevars_at_time_step-Tuple{Any, CTDirect.DOCP, Any, Any}","page":"Common","title":"CTDirect.get_stagevars_at_time_step","text":"get_stagevars_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i,\n    j\n) -> Any\n\n\nRetrieve stage variables at given time step/stage from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1),\t1 <= j <= s Vector output Note that passing correct indices is up to the caller, no checks are made here.\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.runningCost-Union{Tuple{D}, Tuple{CTDirect.DOCP{D}, Any, Any, Any}} where D<:CTDirect.Discretization","page":"Common","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost (must be implemented for each discretization scheme)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"Common","title":"CTDirect.setWorkArray","text":"setWorkArray(docp::CTDirect.DOCP, xu, time_grid, v) -> Any\n\n\nSet work array for all dynamics evaluations\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.set_control_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.set_control_at_time_step!","text":"set_control_at_time_step!(\n    xu,\n    u_init,\n    docp::CTDirect.DOCP,\n    i\n)\n\n\nSet initial guess for control variables at given time step Convention: 1 <= i <= dimNLPsteps(+1)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.set_optim_variable!-Tuple{Any, Any, Any}","page":"Common","title":"CTDirect.set_optim_variable!","text":"set_optim_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.set_state_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.set_state_at_time_step!","text":"set_state_at_time_step!(xu, x_init, docp::CTDirect.DOCP, i)\n\n\nSet initial guess for state variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"irk.html#IRK","page":"IRK","title":"IRK","text":"","category":"section"},{"location":"irk.html#Index","page":"IRK","title":"Index","text":"Pages   = [\"irk.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"irk.html#Documentation","page":"IRK","title":"Documentation","text":"","category":"section"},{"location":"irk.html#CTDirect.Gauss_Legendre_1","page":"IRK","title":"CTDirect.Gauss_Legendre_1","text":"Implicit Midpoint discretization, formulated as a generic IRK (ie Gauss Legendre 1) For testing purpose only, use :midpoint instead (cf midpoint.jl) !\n\n\n\n\n\n","category":"type"},{"location":"irk.html#CTDirect.Gauss_Legendre_2","page":"IRK","title":"CTDirect.Gauss_Legendre_2","text":"Gauss Legendre 2 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"irk.html#CTDirect.Gauss_Legendre_3","page":"IRK","title":"CTDirect.Gauss_Legendre_3","text":"Gauss Legendre 3 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"irk.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"IRK","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"IRK","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.IRK_dims-NTuple{7, Any}","page":"IRK","title":"CTDirect.IRK_dims","text":"IRK_dims(\n    dim_NLP_steps,\n    dim_NLP_x,\n    dim_NLP_u,\n    dim_NLP_v,\n    dim_path_cons,\n    dim_boundary_cons,\n    stage\n) -> NTuple{5, Any}\n\n\nReturn the dimension of the NLP variables and constraints for a generic IRK discretizion, with the control taken constant per step (ie not distinct controls at time stages)\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.runningCost-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any, Any}","page":"IRK","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Vararg{Any, 6}}","page":"IRK","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps (+1)\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any, Any}","page":"IRK","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#Midpoint","page":"Midpoint","title":"Midpoint","text":"","category":"section"},{"location":"midpoint.html#Index","page":"Midpoint","title":"Index","text":"Pages   = [\"midpoint.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"midpoint.html#Documentation","page":"Midpoint","title":"Documentation","text":"","category":"section"},{"location":"midpoint.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"Midpoint","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"Midpoint","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.runningCost-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Any, Any}","page":"Midpoint","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Vararg{Any, 6}}","page":"Midpoint","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Any, Any}","page":"Midpoint","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"euler.html#Euler","page":"Euler","title":"Euler","text":"","category":"section"},{"location":"euler.html#Index","page":"Euler","title":"Index","text":"Pages   = [\"euler.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"euler.html#Documentation","page":"Euler","title":"Documentation","text":"","category":"section"},{"location":"euler.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Euler}}","page":"Euler","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Euler}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Euler}}","page":"Euler","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Euler}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Euler}, Any}","page":"Euler","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: see above for explicit / implicit versions Vector output\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.runningCost-Tuple{CTDirect.DOCP{CTDirect.Euler}, Any, Any, Any}","page":"Euler","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Euler}, Vararg{Any, 6}}","page":"Euler","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Euler}, Any, Any, Any}","page":"Euler","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"index.html#CTDirect.jl","page":"Introduction","title":"CTDirect.jl","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.\n\nThe root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.\n\nTo install a package from the control-toolbox ecosystem, please visit the installation page.","category":"section"},{"location":"index.html#API-Documentation","page":"Introduction","title":"API Documentation","text":"Pages = Main.API_PAGES\nDepth = 1","category":"section"},{"location":"index.html#Brief-Overview","page":"Introduction","title":"Brief Overview","text":"An optimal control problem with fixed initial and final times, denoted (OCP), can be described as minimising the cost functional\n\ng(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt\n\nwhere the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint\n\n   dotx(t) = f(t x(t) u(t))\n\nand other constraints such as\n\nbeginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray\n\nThe so-called direct approach transforms the infinite dimensional optimal control problem (OCP) into a finite dimensional optimization problem (NLP). This is done by a discretization in time by Runge-Kutta methods applied to the state and control variables, as well as the dynamics equation. These methods are usually less precise than indirect methods based on Pontryagin’s Maximum Principle, but more robust with respect to the initialization. Also, they are more straightforward to apply, hence their wide use in industrial applications. We refer the reader to for instance[1] and [2] for more details on direct transcription methods and NLP algorithms.\n\n[1]: J. T. Betts. Practical methods for optimal control using nonlinear programming. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2001.\n\n[2]: J. Nocedal and S.J. Wright. Numerical optimization. Springer-Verlag, New York, 1999.****\n\nExample of the time discretization by the trapezoidal rule:\n\nbeginarraylcl\nt in t_0t_f    to  t_0 ldots t_N=t_f02em\nx(cdot) u(cdot)  to  X=x_0 ldots x_N u_0 ldots u_N 1em\nhline\n\ntextstep  to  h = (t_f-t_0)N02em\ntextcriterion  to  min g(x_0 x_N) 02em\ntextdynamics   to  x_i+i = x_i + (h2) (f(t_i x_i u_i) + f(t_i+1 x_i+1 u_i+1)) 02em\ntextcontrol constraints to xi_l  le  xi(t_i u_i)   le xi_u 02em\ntextpath constraints to eta_l le eta(t_i x_i)        le eta_u 02em\ntextmixed constraints to psi_l le psi(t_i x_i u_i) le psi_u 02em\ntextlimit conditions to phi_l le phi(x_0 x_N) le phi_u\nendarray\n\nWe therefore obtain a nonlinear programming problem on the discretized state and control variables of the general form:\n\n(NLP)quad left\nbeginarraylr\nmin  F(X) \nLB le C(X) le UB\nendarray\nright\n\nSolving the (NLP) problem is done using packages from JuliaSmoothOptimizers, with Ipopt as the default solver.\n\nOn the input side of this package, we use a Model structure from CTModels to define the (OCP).\n\nThe direct transcription to build the (NLP) can use discretization schemes such as trapeze (default), midpoint, or Gauss-Legendre collocations.\n\nnote: Related packages\nThis package is a successor to the bocop software.\n\n","category":"section"},{"location":"trapeze.html#Trapeze","page":"Trapeze","title":"Trapeze","text":"","category":"section"},{"location":"trapeze.html#Index","page":"Trapeze","title":"Index","text":"Pages   = [\"trapeze.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"trapeze.html#Documentation","page":"Trapeze","title":"Documentation","text":"","category":"section"},{"location":"trapeze.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"Trapeze","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"Trapeze","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.runningCost-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Any, Any}","page":"Trapeze","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Vararg{Any, 6}}","page":"Trapeze","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Any, Any}","page":"Trapeze","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics evaluations\n\n\n\n\n\n","category":"method"}]
}
