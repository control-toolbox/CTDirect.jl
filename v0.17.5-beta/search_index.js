var documenterSearchIndex = {"docs":
[{"location":"docp.html#DOCP","page":"DOCP","title":"DOCP","text":"","category":"section"},{"location":"docp.html#Index","page":"DOCP","title":"Index","text":"Pages   = [\"docp.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"docp.html#Documentation","page":"DOCP","title":"Documentation","text":"","category":"section"},{"location":"docp.html#CTDirect.DOCP","page":"DOCP","title":"CTDirect.DOCP","text":"mutable struct DOCP{D<:CTDirect.Discretization, O<:CTModels.Model, N<:CTDirect.AbstractNLPModelBackend}\n\nStruct representing a discretized optimal control problem (DOCP).\n\nFields\n\ndiscretization::D: The discretization scheme.\nocp::O: The original OCP model.\nnlp_model_backend::N: The NLP model backend.\nnlp: The constructed NLP instance.\nexa_getter::Union{Nothing,Function}: Getter for ExaModels if used.\nflags::DOCPFlags: Boolean flags describing problem structure.\ndims::DOCPdims: Problem dimensions.\ntime::DOCPtime: Time discretization.\nbounds::DOCPbounds: Variable and constraint bounds.\ndim_NLP_variables::Int: Number of NLP variables.\ndim_NLP_constraints::Int: Number of NLP constraints.\n\nExample\n\njulia> DOCP(ocp, nlp_model_backend)\nDOCP{...}(...)\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCPFlags","page":"DOCP","title":"CTDirect.DOCPFlags","text":"struct DOCPFlags\n\nInternal struct holding boolean flags that characterize properties of the  discretized optimal control problem (DOCP).\n\nFields\n\nfreet0::Bool: Whether the OCP has a free initial time.\nfreetf::Bool: Whether the OCP has a free final time.\nlagrange::Bool: Whether the OCP includes a Lagrange cost.\nmayer::Bool: Whether the OCP includes a Mayer cost.\nlagrange_to_mayer::Bool: Whether the Lagrange cost is reformulated as a Mayer term.\nmax::Bool: Whether the OCP is a maximization problem.\n\nExample\n\njulia> DOCPFlags(true, false, true, true, false, false)\nDOCPFlags(true, false, true, true, false, false)\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCPFlags-Tuple{CTModels.Model, Bool}","page":"DOCP","title":"CTDirect.DOCPFlags","text":"DOCPFlags(\n    ocp::CTModels.Model,\n    lagrange_to_mayer::Bool\n) -> CTDirect.DOCPFlags\n\n\nConstruct a DOCPFlags struct from an OCP model.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem model.\nlagrange_to_mayer::Bool: Whether to reformulate the Lagrange cost as a Mayer term.\n\nReturns\n\nDOCPFlags: A struct encoding the problem’s boolean properties.\n\nExample\n\njulia> DOCPFlags(ocp, true)\nDOCPFlags(false, true, true, false, true, false)\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.DOCPbounds","page":"DOCP","title":"CTDirect.DOCPbounds","text":"struct DOCPbounds\n\nInternal struct holding variable and constraint bounds for a DOCP.\n\nFields\n\nvar_l::Vector{Float64}: Lower bounds for NLP variables.\nvar_u::Vector{Float64}: Upper bounds for NLP variables.\ncon_l::Vector{Float64}: Lower bounds for NLP constraints.\ncon_u::Vector{Float64}: Upper bounds for NLP constraints.\n\nExample\n\njulia> DOCPbounds([-1.0, -2.0], [1.0, 2.0], [0.0], [0.0])\nDOCPbounds([-1.0, -2.0], [1.0, 2.0], [0.0], [0.0])\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCPdims","page":"DOCP","title":"CTDirect.DOCPdims","text":"struct DOCPdims\n\nInternal struct holding problem dimensions for a DOCP.\n\nFields\n\nNLP_x::Int: State dimension, possibly including an extra variable for Lagrange cost.\nNLP_u::Int: Control dimension.\nNLP_v::Int: Variable dimension.\nOCP_x::Int: State dimension of the original OCP.\npath_cons::Int: Path constraints dimension.\nboundary_cons::Int: Boundary constraints dimension.\n\nExample\n\njulia> DOCPdims(4, 2, 1, 3, 2, 1)\nDOCPdims(4, 2, 1, 3, 2, 1)\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCPdims-Tuple{CTModels.Model, Bool}","page":"DOCP","title":"CTDirect.DOCPdims","text":"DOCPdims(\n    ocp::CTModels.Model,\n    lagrange_to_mayer::Bool\n) -> CTDirect.DOCPdims\n\n\nConstruct a DOCPdims struct from an OCP model.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem model.\nlagrange_to_mayer::Bool: Whether the Lagrange cost is reformulated as Mayer.\n\nReturns\n\nDOCPdims: A struct containing the problem dimensions.\n\nExample\n\njulia> DOCPdims(ocp, true)\nDOCPdims(5, 2, 1, 4, 2, 1)\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.DOCPtime","page":"DOCP","title":"CTDirect.DOCPtime","text":"struct DOCPtime\n\nInternal struct holding time grid information for a DOCP.\n\nFields\n\nsteps::Int: Number of time steps.\nnormalized_grid::Vector{Float64}: Normalized time grid in [0,1].\nfixed_grid::Vector{Float64}: Fixed time grid in [t0, tf].\n\nExample\n\njulia> DOCPtime(10, collect(0:0.1:1), collect(0.0:0.1:1.0))\nDOCPtime(10, [0.0, 0.1, …, 1.0], [0.0, 0.1, …, 1.0])\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCPtime-Tuple{CTModels.Model, Int64, Any}","page":"DOCP","title":"CTDirect.DOCPtime","text":"DOCPtime(\n    ocp::CTModels.Model,\n    grid_size::Int64,\n    time_grid\n) -> CTDirect.DOCPtime\n\n\nConstruct a DOCPtime struct from an OCP model.\n\nArguments\n\nocp::CTModels.Model: The optimal control problem model.\ngrid_size::Int: Number of grid steps if no grid is provided.\ntime_grid: Custom time grid (or nothing to auto-generate).\n\nReturns\n\nDOCPtime: A struct encoding the time discretization.\n\nExample\n\njulia> DOCPtime(ocp, 10, nothing)\nDOCPtime(10, [0.0, 0.1, …, 1.0], [0.0, 0.1, …, 1.0])\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.Discretization","page":"DOCP","title":"CTDirect.Discretization","text":"abstract type Discretization\n\nAbstract type representing a discretization strategy for an optimal control problem.  \n\nConcrete subtypes of Discretization define specific schemes for transforming a continuous-time problem into a discrete-time representation suitable for numerical solution.\n\nExample\n\njulia> struct MyDiscretization <: Discretization end\nMyDiscretization\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, CTDirect.DOCP}","page":"DOCP","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the nonlinear constraints of a DOCP.\n\nThe constraints are modeled as lb <= C(x) <= ub.\n\nArguments\n\nc: Preallocated constraint vector.\nxu: Vector of NLP decision variables.\ndocp::DOCP: The discretized OCP.\n\nReturns\n\nc: The filled constraint vector.\n\nExample\n\njulia> DOCP_constraints!(zeros(docp.dim_NLP_constraints), xu, docp)\n[0.0, 0.1, …]\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.DOCP_initial_guess","page":"DOCP","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(docp::CTDirect.DOCP) -> Vector{Float64}\nDOCP_initial_guess(\n    docp::CTDirect.DOCP,\n    init::CTModels.Init\n) -> Vector{Float64}\n\n\nBuild an initial guess vector for the discretized OCP.\n\nArguments\n\ndocp::DOCP: The discretized OCP.\ninit::CTModels.Init: Initialization settings (default: CTModels.Init()).\n\nReturns\n\nNLP_X::Vector{Float64}: Initial guess vector.\n\nExample\n\njulia> DOCP_initial_guess(docp)\n[0.1, 0.1, …]\n\n\n\n\n\n","category":"function"},{"location":"docp.html#CTDirect.DOCP_objective-Tuple{Any, CTDirect.DOCP}","page":"DOCP","title":"CTDirect.DOCP_objective","text":"DOCP_objective(xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the objective value of a discretized OCP.\n\nArguments\n\nxu: Vector of NLP decision variables.\ndocp::DOCP: The discretized OCP.\n\nReturns\n\nobj::Float64: Objective function value.\n\nExample\n\njulia> DOCP_objective(xu, docp)\n12.34\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.build_bounds-Tuple{Any, Any, Any}","page":"DOCP","title":"CTDirect.build_bounds","text":"build_bounds(\n    dim_var,\n    dim_box,\n    box_triplet\n) -> Tuple{Any, Any}\n\n\nBuild lower and upper bound vectors for state, control, or optimization variables.\n\nArguments\n\ndim_var::Int: Variable dimension.\ndim_box::Int: Number of box constraints.\nbox_triplet: Triplet defining box constraints.\n\nReturns\n\n(x_lb, x_ub)::Tuple{Vector{Float64},Vector{Float64}}: Lower and upper bounds.\n\nExample\n\njulia> build_bounds(3, 1, ([0.0], [2], [1.0]))\n([-Inf, 0.0, -Inf], [Inf, 1.0, Inf])\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.constraints_bounds!-Tuple{CTDirect.DOCP}","page":"DOCP","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild lower and upper bounds vectors for the nonlinear constraints of a DOCP.\n\nArguments\n\ndocp::DOCP: The discretized OCP.\n\nReturns\n\n(lb, ub)::Tuple{Vector{Float64},Vector{Float64}}: Lower and upper bounds.\n\nExample\n\njulia> constraints_bounds!(docp)\n([-1.0, …], [1.0, …])\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.disc_model-Tuple{CTDirect.DOCP}","page":"DOCP","title":"CTDirect.disc_model","text":"disc_model(docp::CTDirect.DOCP) -> CTDirect.Discretization\n\n\nReturn the discretization model associated with a given discretized optimal control problem (DOCP).\n\nArguments\n\ndocp::DOCP: The discretized optimal control problem.\n\nReturns\n\ndiscretization::Any: The discretization model stored in docp.\n\nExample\n\njulia> disc_model(docp)\nDiscretizationModel(...)\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.get_time_grid-Tuple{Any, CTDirect.DOCP}","page":"DOCP","title":"CTDirect.get_time_grid","text":"get_time_grid(xu, docp::CTDirect.DOCP) -> Any\n\n\nReturn the time grid for problems with free initial or final times.\n\nArguments\n\nxu: Vector of NLP decision variables.\ndocp::DOCP: The discretized OCP.\n\nReturns\n\ngrid::Vector{Float64}: Time grid corresponding to current NLP variables.\n\nExample\n\njulia> get_time_grid(xu, docp)\n[0.0, 0.1, …, 1.0]\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.get_time_grid_exa-Tuple{}","page":"DOCP","title":"CTDirect.get_time_grid_exa","text":"get_time_grid_exa()\n\n\nHelper for invalid execution paths.\n\nAlways throws an error.\n\nExample\n\njulia> get_time_grid_exa()\nERROR: you should not be here\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.is_solvable-Tuple{Any}","page":"DOCP","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by solve.\n\nArguments\n\nocp: The OCP model.\n\nReturns\n\nsolvable::Bool: Always returns true in the current implementation.\n\nExample\n\njulia> is_solvable(ocp)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.nlp_model-Tuple{CTDirect.DOCP}","page":"DOCP","title":"CTDirect.nlp_model","text":"nlp_model(docp::CTDirect.DOCP) -> Any\n\n\nReturn the nonlinear programming (NLP) model associated with a given discretized optimal control problem (DOCP).\n\nArguments\n\ndocp::DOCP: The discretized optimal control problem.\n\nReturns\n\nnlp::Any: The underlying NLP model stored in docp.\n\nExample\n\njulia> nlp_model(docp)\nNLPModel(...)\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.ocp_model-Tuple{CTDirect.DOCP}","page":"DOCP","title":"CTDirect.ocp_model","text":"ocp_model(docp::CTDirect.DOCP) -> CTModels.Model\n\n\nReturn the continuous-time optimal control problem (OCP) model associated with a given discretized optimal control problem (DOCP).\n\nArguments\n\ndocp::DOCP: The discretized optimal control problem.\n\nReturns\n\nocp::Any: The underlying OCP model stored in docp.\n\nExample\n\njulia> ocp_model(docp)\nOCPModel(...)\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.setPointConstraints!-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"DOCP","title":"CTDirect.setPointConstraints!","text":"setPointConstraints!(docp::CTDirect.DOCP, c, xu, v) -> Any\n\n\nSet boundary and variable point constraints for a DOCP.\n\nArguments\n\ndocp::DOCP: The discretized OCP.\nc: Constraint vector to modify.\nxu: Vector of NLP decision variables.\nv: Additional OCP variables.\n\nReturns\n\nnothing: Modifies c in place.\n\nExample\n\njulia> setPointConstraints!(docp, c, xu, v)\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.variables_bounds!-Tuple{CTDirect.DOCP}","page":"DOCP","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild lower and upper bounds vectors for the variable box constraints of a DOCP.\n\nArguments\n\ndocp::DOCP: The discretized OCP.\n\nReturns\n\n(var_l, var_u)::Tuple{Vector{Float64},Vector{Float64}}: Lower and upper bounds for variables.\n\nExample\n\njulia> variables_bounds!(docp)\n([-Inf, …], [Inf, …])\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_adnlp.html#CTDirectExtADNLP","page":"CTDirectExtADNLP","title":"CTDirectExtADNLP","text":"","category":"section"},{"location":"ctdirectext_adnlp.html#Index","page":"CTDirectExtADNLP","title":"Index","text":"Pages   = [\"ctdirectext_adnlp.md\"]\nModules = [CTDirect, CTDirectExtADNLP]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"ctdirectext_adnlp.html#Documentation","page":"CTDirectExtADNLP","title":"Documentation","text":"","category":"section"},{"location":"ctdirectext_adnlp.html#CTDirect.build_nlp!-Tuple{CTDirect.DOCP{<:CTDirect.Discretization, <:CTModels.Model, <:CTDirect.ADNLPBackend}, Any}","page":"CTDirectExtADNLP","title":"CTDirect.build_nlp!","text":"build_nlp!(\n    docp::CTDirect.DOCP{<:CTDirect.Discretization, <:CTModels.Model, <:CTDirect.ADNLPBackend},\n    x0;\n    adnlp_backend,\n    show_time,\n    kwargs...\n)\n\n\nBuild the NLP model for the DOCP (ADNLPModels version)\n\nKeyword arguments (optional)\n\nshow_time: (:true, [:false]) show timing details from ADNLPModels\nadnlp_backend: backend for ADNLPModels ([:optimized], :manual, :default)\n\n\n\n\n\n","category":"method"},{"location":"solve.html#Solve","page":"Solve","title":"Solve","text":"","category":"section"},{"location":"solve.html#Index","page":"Solve","title":"Index","text":"Pages   = [\"solve.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"solve.html#Documentation","page":"Solve","title":"Documentation","text":"","category":"section"},{"location":"solve.html#CTDirect.available_methods-Tuple{}","page":"Solve","title":"CTDirect.available_methods","text":"available_methods() -> NTuple{6, Tuple{Symbol, Symbol}}\n\n\nReturn a tuple of available NLP model and solver combinations for solving optimal control problems.\n\nReturns\n\nalgorithms::Tuple: A tuple of symbol pairs representing the available methods.\n\nExample\n\njulia> available_methods()\n((:adnlp, :ipopt), (:adnlp, :madnlp), (:adnlp, :knitro), (:exa, :ipopt), (:exa, :madnlp), (:exa, :knitro))\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.build_nlp!-Union{Tuple{T}, Tuple{CTDirect.DOCP{<:CTDirect.Discretization, <:CTModels.Model, T}, Any}} where T<:CTDirect.AbstractNLPModelBackend","page":"Solve","title":"CTDirect.build_nlp!","text":"build_nlp!(\n    docp::CTDirect.DOCP{<:CTDirect.Discretization, <:CTModels.Model, T<:CTDirect.AbstractNLPModelBackend},\n    x0;\n    kwargs...\n)\n\n\nBuild the NLP model for a discretized optimal control problem using the specified NLP backend.\n\nArguments\n\ndocp::CTDirect.DOCP: The discretized optimal control problem.\nnlp_model_backend::T: The NLP model backend (subtype of AbstractNLPModelBackend).\nx0: Initial guess for decision variables.\n\nReturns\n\nThrows CTBase.ExtensionError if the NLP model backend is unavailable.\n\nExample\n\njulia> build_nlp!(docp, ADNLPBackend(), x0)\nERROR: ExtensionError(...)\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.direct_transcription-Tuple{CTModels.Model, Vararg{Any}}","page":"Solve","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::CTModels.Model,\n    description...;\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    lagrange_to_mayer,\n    kwargs...\n) -> CTDirect.DOCP\n\n\nConvert a continuous-time optimal control problem into a discretized nonlinear programming problem.\n\nArguments\n\nocp::CTModels.Model: Continuous-time optimal control problem.\ndescription...: Symbols specifying the NLP model ([:adnlp] or :exa) and/or solver ([:ipopt], :madnlp or :knitro).\n\nKeyword Arguments (optional)\n\ngrid_size::Int: Number of discretization steps ([250]).\ndisc_method: Discretization scheme (:trapeze, :euler, :euler_implicit, [:midpoint], gauss_legendre_2, gauss_legendre_3).\ntime_grid: Explicit time grid (can be non uniform).\ninit: Initial guess values or existing solution.\nlagrange_to_mayer::Bool: Convert Lagrange cost to Mayer cost (true or false).\nkwargs...: Additional arguments passed to the NLP modeler.\n\nReturns\n\ndocp::CTDirect.DOCP: Discretized optimal control problem ready for NLP solving.\n\nExample\n\njulia> docp = direct_transcription(ocp, :adnlp, :ipopt; grid_size=100, disc_method=:trapeze)\nCTDirect.DOCP(...)\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.display_method-Tuple{Any, Vararg{Symbol}}","page":"Solve","title":"CTDirect.display_method","text":"display_method(\n    ocp,\n    description::Symbol...;\n    grid_size,\n    disc_method,\n    time_grid,\n    kwargs...\n)\n\n\nDisplay information about the chosen NLP model, solver, discretization scheme, and number of steps.\n\nArguments\n\nocp: The continuous-time optimal control problem.\ndescription::Symbol...: Symbols specifying the solver and model.\ngrid_size::Int: Number of time steps.\ndisc_method: Discretization scheme.\ntime_grid: Optional explicit time grid.\nkwargs...: Additional keyword arguments.\n\nReturns\n\nnothing\n\nExample\n\njulia> display_method(ocp, :adnlp, :ipopt; grid_size=100, disc_method=:trapeze)\n▫ The optimal control problem is solved with CTDirect version vX.Y.Z.\n...\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.parse_description-Tuple{Any, Any}","page":"Solve","title":"CTDirect.parse_description","text":"parse_description(\n    description,\n    info\n) -> Union{CTDirect.ADNLPBackend, CTDirect.ExaBackend, CTDirect.IpoptBackend, CTDirect.KnitroBackend, CTDirect.MadNLPBackend}\n\n\nParse the method description to determine the NLP solver or model.\n\nArguments\n\ndescription: A tuple of symbols representing the desired solver and/or model.\nNLP solver: ipopt, madnlp or knitro \nNLP model: :adnlp or :exa\ninfo::Symbol: Either :solver to return the solver backend or :model to return the NLP model backend.\n\nReturns\n\nnlp_solver_backend or nlp_model_backend: The corresponding backend instance.\n\nExample\n\njulia> parse_description((:adnlp, :ipopt), :solver)\nCTDirect.IpoptBackend()\n\njulia> parse_description((:exa, :madnlp), :model)\nCTDirect.ExaBackend()\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.set_initial_guess-Tuple{CTDirect.DOCP, Any}","page":"Solve","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, init) -> Any\n\n\nSet the initial guess for the decision variables in a discretized optimal control problem.\n\nArguments\n\ndocp::DOCP: The discretized optimal control problem.\ninit: Initial guess values as a named tuple or existing solution.\n\nReturns\n\nnothing\n\nExample\n\njulia> set_initial_guess(docp, init)\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.solve-Tuple{CTModels.Model, Vararg{Symbol}}","page":"Solve","title":"CTDirect.solve","text":"solve(\n    ocp::CTModels.Model,\n    description::Symbol...;\n    display,\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    lagrange_to_mayer,\n    adnlp_backend,\n    exa_backend,\n    kwargs...\n) -> CTModels.Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#84#85\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#86#87\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#88#89\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#90#91\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#92#93\", CTModels.var\"#94#95\"}, DualModelType<:(CTModels.DualModel{PC_Dual, Vector{Float64}, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, Vector{Float64}, Vector{Float64}} where {PC_Dual<:Union{CTModels.var\"#100#101\"{CTModels.var\"#96#97\"}, CTModels.var\"#98#99\"{CTModels.var\"#96#97\"}}, SC_LB_Dual<:Union{CTModels.var\"#104#105\"{CTModels.var\"#102#103\"}, CTModels.var\"#106#107\"{CTModels.var\"#102#103\"}}, SC_UB_Dual<:Union{CTModels.var\"#110#111\"{CTModels.var\"#108#109\"}, CTModels.var\"#112#113\"{CTModels.var\"#108#109\"}}, CC_LB_Dual<:Union{CTModels.var\"#116#117\"{CTModels.var\"#114#115\"}, CTModels.var\"#118#119\"{CTModels.var\"#114#115\"}}, CC_UB_Dual<:Union{CTModels.var\"#122#123\"{CTModels.var\"#120#121\"}, CTModels.var\"#124#125\"{CTModels.var\"#120#121\"}}}), ModelType<:(CTModels.Model{<:CTModels.TimeDependence, T} where T<:CTModels.TimesModel)}\n\n\nSolve an optimal control problem using a direct transcription method.\n\nArguments\n\nocp::CTModels.Model: The continuous-time optimal control problem.\ndescription::Symbol...: Symbols specifying the NLP model (:adnlp or :exa) and/or solver (:ipopt, :madnlp, :knitro).\n\nKeyword Arguments (optional)\n\ndisplay::Bool: Display solver output ([true], false).\ngrid_size::Int: Number of discretization steps ([250]).\ndisc_method: Discretization scheme (:trapeze, [:midpoint], :gauss_legendre_2, etc.).\ntime_grid: Explicit time grid, uniform or not.\ninit: Initial guess for states, controls, or variables.\nadnlp_backend, exa_backend: Backend options for NLP modelers.\nlagrange_to_mayer: Convert Lagrange cost to Mayer cost\nkwargs...: Additional parameters passed to NLP modelers and solvers.\n\nReturns\n\nsolution::CTModels.Solution: The continuous-time solution with objective, state/control trajectories, solver status, and convergence information. Main features:\nobjective(sol): value of the objective\nstate(sol), control(sol): functions for state and control variables (trajectory)\nvariable(sol): optimization variables if any (e.g. free final time)\nsuccessful(sol): boolean indicating successful convergence of the NLP solver\nstatus(sol): symbol for the return code of the NLP solver\nmessage(sol): string with specific info from the NLP solver, if any\nconstraints_violation(sol): primal feasibility at the solution\niterations(sol): number of iterations \n\nExample\n\njulia> sol = solve(ocp, :adnlp, :ipopt; grid_size=100)\nCTModels.Solution(...)\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.solve_docp-Union{Tuple{T}, Tuple{T, CTDirect.DOCP}} where T<:CTDirect.AbstractNLPSolverBackend","page":"Solve","title":"CTDirect.solve_docp","text":"solve_docp(\n    solver_backend::CTDirect.AbstractNLPSolverBackend,\n    docp::CTDirect.DOCP;\n    kwargs...\n) -> MadNLP.MadNLPExecutionStats\n\n\nSolve a discretized optimal control problem using the specified solver backend.\n\nArguments\n\nsolver_backend::T: An NLP solver backend (subtype of AbstractNLPSolverBackend).\ndocp::CTDirect.DOCP: The discretized optimal control problem.\n\nReturns\n\nThrows CTBase.ExtensionError if the solver backend is unavailable.\n\nExample\n\njulia> solve_docp(IpoptBackend(), docp)\nERROR: ExtensionError(...)\n\n\n\n\n\n","category":"method"},{"location":"default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"default.html#Index","page":"Default","title":"Index","text":"Pages   = [\"default.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"default.html#Documentation","page":"Default","title":"Documentation","text":"","category":"section"},{"location":"default.html#CTDirect.__adnlp_backend-Tuple{}","page":"Default","title":"CTDirect.__adnlp_backend","text":"__adnlp_backend() -> Symbol\n\n\nDefault backend for ADNLPModels: :optimized\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__disc_method-Tuple{}","page":"Default","title":"CTDirect.__disc_method","text":"__disc_method() -> Symbol\n\n\nDefault discretization method: midpoint.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__display-Tuple{}","page":"Default","title":"CTDirect.__display","text":"__display() -> Bool\n\n\nDefault display toggle: true\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__exa_backend-Tuple{}","page":"Default","title":"CTDirect.__exa_backend","text":"__exa_backend()\n\n\nDefault backend for ExaModels: nothing\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__grid_size-Tuple{}","page":"Default","title":"CTDirect.__grid_size","text":"__grid_size() -> Int64\n\n\nDefault grid size: 250.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__lagrange_to_mayer-Tuple{}","page":"Default","title":"CTDirect.__lagrange_to_mayer","text":"__lagrange_to_mayer() -> Bool\n\n\nReformulate Lagrange cost as Mayer cost: false\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__max_iterations-Tuple{}","page":"Default","title":"CTDirect.__max_iterations","text":"__max_iterations() -> Int64\n\n\nDefault maximum of iterations: 1000\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__ocp_init-Tuple{}","page":"Default","title":"CTDirect.__ocp_init","text":"__ocp_init()\n\n\nDefault initial guess: nothing (corresponds to 0.1 for all variables)\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__time_grid-Tuple{}","page":"Default","title":"CTDirect.__time_grid","text":"__time_grid()\n\n\nDefault (non uniform) time grid: nothing\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__tolerance-Tuple{}","page":"Default","title":"CTDirect.__tolerance","text":"__tolerance() -> Float64\n\n\nDefault tolerance: 1e-8\n\n\n\n\n\n","category":"method"},{"location":"utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils.html#Index","page":"Utils","title":"Index","text":"Pages   = [\"utils.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"utils.html#Documentation","page":"Utils","title":"Documentation","text":"","category":"section"},{"location":"utils.html#CTDirect.package_loaded-Tuple{String}","page":"Utils","title":"CTDirect.package_loaded","text":"package_loaded(pkg::String) -> Bool\n\n\nCheck whether a package with the given name is currently loaded.\n\nArguments\n\npkg::String: The name of the package to check.\n\nReturns\n\nis_loaded::Bool: true if the package is loaded, false otherwise.\n\nExample\n\njulia> package_loaded(\"LinearAlgebra\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"utils.html#CTDirect.version-Tuple{}","page":"Utils","title":"CTDirect.version","text":"version() -> String\n\n\nReturn the version number of the current package as a string.\n\nReturns\n\nversion::String: The version of the current module.\n\nExample\n\njulia> version()\n\"1.2.3\"\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_knitro.html#CTDirectExtKnitro","page":"CTDirectExtKnitro","title":"CTDirectExtKnitro","text":"","category":"section"},{"location":"ctdirectext_knitro.html#Index","page":"CTDirectExtKnitro","title":"Index","text":"Pages   = [\"ctdirectext_knitro.md\"]\nModules = [CTDirect, CTDirectExtKnitro]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"ctdirectext_knitro.html#Documentation","page":"CTDirectExtKnitro","title":"Documentation","text":"","category":"section"},{"location":"ctdirectext_knitro.html#CTDirect.solve_docp-Tuple{CTDirect.KnitroBackend, CTDirect.DOCP}","page":"CTDirectExtKnitro","title":"CTDirect.solve_docp","text":"solve_docp(\n    ::CTDirect.KnitroBackend,\n    docp::CTDirect.DOCP;\n    display,\n    max_iter,\n    tol,\n    print_level,\n    kwargs...\n) -> Union{Nothing, SolverCore.GenericExecutionStats{T, S} where {T>:Float64, S>:Vector{Float64}}}\n\n\nSolve a discretized optimal control problem with Ipopt\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_knitro.html#CTDirectExtKnitro.__knitro_print_level-Tuple{}","page":"CTDirectExtKnitro","title":"CTDirectExtKnitro.__knitro_print_level","text":"__knitro_print_level() -> Int64\n\n\nDefault value for Knitro print level: 3\n\n\n\n\n\n","category":"method"},{"location":"common.html#Common","page":"Common","title":"Common","text":"","category":"section"},{"location":"common.html#Index","page":"Common","title":"Index","text":"Pages   = [\"common.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"common.html#Documentation","page":"Common","title":"Documentation","text":"","category":"section"},{"location":"common.html#CTDirect.DOCP_Hessian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"Common","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.DOCP_Jacobian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"Common","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.add_nonzero_block!-NTuple{5, Any}","page":"Common","title":"CTDirect.add_nonzero_block!","text":"add_nonzero_block!(M, i_start, i_end, j_start, j_end; sym)\n\n\nAdd block of nonzeros elements to a sparsity pattern  Format: boolean matrix (M) or index vectors (Is, Js)  Includes a more compact method for single element case Option to add the symmetric block also (eg for Hessian) Note: independent from discretization scheme\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1), with convention u(tf) = U_N Vector output\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_OCP_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.get_OCP_state_at_time_step","text":"get_OCP_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Vector output\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_OCP_variable-Tuple{Any, CTDirect.DOCP}","page":"Common","title":"CTDirect.get_OCP_variable","text":"get_OCP_variable(xu, docp::CTDirect.DOCP) -> Any\n\n\nRetrieve optimization variables from the NLP variables. Convention: stored at the end, hence not dependent on the discretization method Vector output\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_lagrange_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.get_lagrange_state_at_time_step","text":"get_lagrange_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variable for lagrange cost at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1   (no check for actual lagrange cost presence !)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_stagevars_at_time_step-Tuple{Any, CTDirect.DOCP, Any, Any}","page":"Common","title":"CTDirect.get_stagevars_at_time_step","text":"get_stagevars_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i,\n    j\n) -> Any\n\n\nRetrieve stage variables at given time step/stage from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1),\t1 <= j <= s Vector output Note that passing correct indices is up to the caller, no checks are made here.\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.runningCost-Union{Tuple{D}, Tuple{CTDirect.DOCP{D}, Any, Any, Any}} where D<:CTDirect.Discretization","page":"Common","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"Common","title":"CTDirect.setWorkArray","text":"setWorkArray(docp::CTDirect.DOCP, xu, time_grid, v) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.set_control_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.set_control_at_time_step!","text":"set_control_at_time_step!(\n    xu,\n    u_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for control variables at given time step Convention: 1 <= i <= dimNLPsteps(+1)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.set_optim_variable!-Tuple{Any, Any, Any}","page":"Common","title":"CTDirect.set_optim_variable!","text":"set_optim_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.set_state_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.set_state_at_time_step!","text":"set_state_at_time_step!(\n    xu,\n    x_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for state variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"irk.html#IRK","page":"IRK","title":"IRK","text":"","category":"section"},{"location":"irk.html#Index","page":"IRK","title":"Index","text":"Pages   = [\"irk.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"irk.html#Documentation","page":"IRK","title":"Documentation","text":"","category":"section"},{"location":"irk.html#CTDirect.Gauss_Legendre_1","page":"IRK","title":"CTDirect.Gauss_Legendre_1","text":"Implicit Midpoint discretization, formulated as a generic IRK (ie Gauss Legendre 1) For testing purpose only, use :midpoint instead (cf midpoint.jl) !\n\n\n\n\n\n","category":"type"},{"location":"irk.html#CTDirect.Gauss_Legendre_2","page":"IRK","title":"CTDirect.Gauss_Legendre_2","text":"Gauss Legendre 2 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"irk.html#CTDirect.Gauss_Legendre_3","page":"IRK","title":"CTDirect.Gauss_Legendre_3","text":"Gauss Legendre 3 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"irk.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"IRK","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"IRK","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.IRK_dims-NTuple{7, Any}","page":"IRK","title":"CTDirect.IRK_dims","text":"IRK_dims(\n    dim_NLP_steps,\n    dim_NLP_x,\n    dim_NLP_u,\n    dim_NLP_v,\n    dim_path_cons,\n    dim_boundary_cons,\n    stage\n) -> NTuple{5, Any}\n\n\nReturn the dimension of the NLP variables and constraints for a generic IRK discretizion, with the control taken constant per step (ie not distinct controls at time stages)\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.runningCost-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any, Any}","page":"IRK","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Vararg{Any, 6}}","page":"IRK","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps (+1)\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any, Any}","page":"IRK","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_madnlp.html#CTDirectExtMadNLP","page":"CTDirectExtMadNLP","title":"CTDirectExtMadNLP","text":"","category":"section"},{"location":"ctdirectext_madnlp.html#Index","page":"CTDirectExtMadNLP","title":"Index","text":"Pages   = [\"ctdirectext_madnlp.md\"]\nModules = [CTDirect, CTDirectExtMadNLP]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"ctdirectext_madnlp.html#Documentation","page":"CTDirectExtMadNLP","title":"Documentation","text":"","category":"section"},{"location":"ctdirectext_madnlp.html#CTDirect.solve_docp-Tuple{CTDirect.MadNLPBackend, CTDirect.DOCP}","page":"CTDirectExtMadNLP","title":"CTDirect.solve_docp","text":"solve_docp(\n    ::CTDirect.MadNLPBackend,\n    docp::CTDirect.DOCP;\n    display,\n    max_iter,\n    tol,\n    print_level,\n    kwargs...\n) -> MadNLP.MadNLPExecutionStats\n\n\nSolve a discretized optimal control problem DOCP\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_madnlp.html#CTDirectExtMadNLP.__madnlp_print_level-Tuple{}","page":"CTDirectExtMadNLP","title":"CTDirectExtMadNLP.__madnlp_print_level","text":"__madnlp_print_level() -> MadNLP.LogLevels\n\n\nDefault value for MadNLP print level: MadNLP.INFO Valid values are: MadNLP.{TRACE, DEBUG, INFO, NOTICE, WARN, ERROR}.\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_ipopt.html#CTDirectExtIpopt","page":"CTDirectExtIpopt","title":"CTDirectExtIpopt","text":"","category":"section"},{"location":"ctdirectext_ipopt.html#Index","page":"CTDirectExtIpopt","title":"Index","text":"Pages   = [\"ctdirectext_ipopt.md\"]\nModules = [CTDirect, CTDirectExtIpopt]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"ctdirectext_ipopt.html#Documentation","page":"CTDirectExtIpopt","title":"Documentation","text":"","category":"section"},{"location":"ctdirectext_ipopt.html#CTDirect.solve_docp-Tuple{CTDirect.IpoptBackend, CTDirect.DOCP}","page":"CTDirectExtIpopt","title":"CTDirect.solve_docp","text":"solve_docp(\n    ::CTDirect.IpoptBackend,\n    docp::CTDirect.DOCP;\n    display,\n    max_iter,\n    tol,\n    print_level,\n    mu_strategy,\n    linear_solver,\n    kwargs...\n) -> Union{Nothing, SolverCore.GenericExecutionStats{T, S} where {T>:Float64, S>:Vector{Float64}}}\n\n\nSolve a discretized optimal control problem (Ipopt version).\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_ipopt.html#CTDirectExtIpopt.__ipopt_linear_solver-Tuple{}","page":"CTDirectExtIpopt","title":"CTDirectExtIpopt.__ipopt_linear_solver","text":"__ipopt_linear_solver() -> String\n\n\nDefault value for Ipopt linear solver: mumps\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_ipopt.html#CTDirectExtIpopt.__ipopt_mu_strategy-Tuple{}","page":"CTDirectExtIpopt","title":"CTDirectExtIpopt.__ipopt_mu_strategy","text":"__ipopt_mu_strategy() -> String\n\n\nDefault value for Ipopt mu strategy: adaptive\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_ipopt.html#CTDirectExtIpopt.__ipopt_print_level-Tuple{}","page":"CTDirectExtIpopt","title":"CTDirectExtIpopt.__ipopt_print_level","text":"__ipopt_print_level() -> Int64\n\n\nDefault value for Ipopt print level: 5\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#Midpoint","page":"Midpoint","title":"Midpoint","text":"","category":"section"},{"location":"midpoint.html#Index","page":"Midpoint","title":"Index","text":"Pages   = [\"midpoint.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"midpoint.html#Documentation","page":"Midpoint","title":"Documentation","text":"","category":"section"},{"location":"midpoint.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"Midpoint","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"Midpoint","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.runningCost-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Any, Any}","page":"Midpoint","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Vararg{Any, 6}}","page":"Midpoint","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Any, Any}","page":"Midpoint","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_exa.html#CTDirectExtExa","page":"CTDirectExtExa","title":"CTDirectExtExa","text":"","category":"section"},{"location":"ctdirectext_exa.html#Index","page":"CTDirectExtExa","title":"Index","text":"Pages   = [\"ctdirectext_exa.md\"]\nModules = [CTDirect, CTDirectExtExa]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"ctdirectext_exa.html#Documentation","page":"CTDirectExtExa","title":"Documentation","text":"","category":"section"},{"location":"ctdirectext_exa.html#CTDirect.build_nlp!-Tuple{CTDirect.DOCP{<:CTDirect.Discretization, <:CTModels.Model, <:CTDirect.ExaBackend}, Any}","page":"CTDirectExtExa","title":"CTDirect.build_nlp!","text":"build_nlp!(\n    docp::CTDirect.DOCP{<:CTDirect.Discretization, <:CTModels.Model, <:CTDirect.ExaBackend},\n    x0;\n    grid_size,\n    disc_method,\n    exa_backend,\n    kwargs...\n)\n\n\nBuild the NLP model for the DOCP (ExaModels version)\n\nKeyword arguments (optional)\n\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :euler)\nexa_backend: backend for ExaModels ([nothing])\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_exa.html#CTDirect.get_time_grid_exa-Tuple{SolverCore.AbstractExecutionStats, CTDirect.DOCP}","page":"CTDirectExtExa","title":"CTDirect.get_time_grid_exa","text":"get_time_grid_exa(\n    nlp_solution::SolverCore.AbstractExecutionStats,\n    docp::CTDirect.DOCP\n) -> Vector{Float64}\n\n\nRetrieve the time grid from the given DOCP solution.\n\nArguments\n\nnlp_solution: The DOCP solution.\ndocp: The DOCP.\n\nReturns\n\n::Vector{Float64}: The time grid.\n\n\n\n\n\n","category":"method"},{"location":"euler.html#Euler","page":"Euler","title":"Euler","text":"","category":"section"},{"location":"euler.html#Index","page":"Euler","title":"Index","text":"Pages   = [\"euler.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"euler.html#Documentation","page":"Euler","title":"Documentation","text":"","category":"section"},{"location":"euler.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Euler}}","page":"Euler","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Euler}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Euler}}","page":"Euler","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Euler}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Euler}, Any}","page":"Euler","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: see above for explicit / implicit versions Vector output\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.runningCost-Tuple{CTDirect.DOCP{CTDirect.Euler}, Any, Any, Any}","page":"Euler","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Euler}, Vararg{Any, 6}}","page":"Euler","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Euler}, Any, Any, Any}","page":"Euler","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"index.html#CTDirect.jl","page":"Introduction","title":"CTDirect.jl","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.\n\nThe root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.\n\nTo install a package from the control-toolbox ecosystem, please visit the installation page.","category":"section"},{"location":"index.html#API-Documentation","page":"Introduction","title":"API Documentation","text":"Pages = Main.API_PAGES\nDepth = 1","category":"section"},{"location":"index.html#Brief-Overview","page":"Introduction","title":"Brief Overview","text":"An optimal control problem with fixed initial and final times, denoted (OCP), can be described as minimising the cost functional\n\ng(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt\n\nwhere the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint\n\n   dotx(t) = f(t x(t) u(t))\n\nand other constraints such as\n\nbeginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray\n\nThe so-called direct approach transforms the infinite dimensional optimal control problem (OCP) into a finite dimensional optimization problem (NLP). This is done by a discretization in time by Runge-Kutta methods applied to the state and control variables, as well as the dynamics equation. These methods are usually less precise than indirect methods based on Pontryagin’s Maximum Principle, but more robust with respect to the initialization. Also, they are more straightforward to apply, hence their wide use in industrial applications. We refer the reader to for instance[1] and [2] for more details on direct transcription methods and NLP algorithms.\n\n[1]: J. T. Betts. Practical methods for optimal control using nonlinear programming. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2001.\n\n[2]: J. Nocedal and S.J. Wright. Numerical optimization. Springer-Verlag, New York, 1999.****\n\nExample of the time discretization by the trapezoidal rule:\n\nbeginarraylcl\nt in t_0t_f    to  t_0 ldots t_N=t_f02em\nx(cdot) u(cdot)  to  X=x_0 ldots x_N u_0 ldots u_N 1em\nhline\n\ntextstep  to  h = (t_f-t_0)N02em\ntextcriterion  to  min g(x_0 x_N) 02em\ntextdynamics   to  x_i+i = x_i + (h2) (f(t_i x_i u_i) + f(t_i+1 x_i+1 u_i+1)) 02em\ntextcontrol constraints to xi_l  le  xi(t_i u_i)   le xi_u 02em\ntextpath constraints to eta_l le eta(t_i x_i)        le eta_u 02em\ntextmixed constraints to psi_l le psi(t_i x_i u_i) le psi_u 02em\ntextlimit conditions to phi_l le phi(x_0 x_N) le phi_u\nendarray\n\nWe therefore obtain a nonlinear programming problem on the discretized state and control variables of the general form:\n\n(NLP)quad left\nbeginarraylr\nmin  F(X) \nLB le C(X) le UB\nendarray\nright\n\nSolving the (NLP) problem is done using packages from JuliaSmoothOptimizers, with Ipopt as the default solver.\n\nOn the input side of this package, we use a Model structure from CTModels to define the (OCP).\n\nThe direct transcription to build the (NLP) can use discretization schemes such as trapeze (default), midpoint, or Gauss-Legendre collocations.\n\nnote: Related packages\nThis package is a successor to the bocop software.\n\n","category":"section"},{"location":"solution.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"solution.html#Index","page":"Solution","title":"Index","text":"Pages   = [\"solution.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"solution.html#Documentation","page":"Solution","title":"Documentation","text":"","category":"section"},{"location":"solution.html#CTDirect.SolverInfos-Tuple{SolverCore.AbstractExecutionStats, NLPModels.AbstractNLPModel}","page":"Solution","title":"CTDirect.SolverInfos","text":"SolverInfos(\n    nlp_solution::SolverCore.AbstractExecutionStats,\n    _::NLPModels.AbstractNLPModel\n) -> Tuple{Any, Int64, Any, String, Symbol, Bool}\n\n\nRetrieve convergence information from an NLP solution.\n\nArguments\n\nnlp_solution: A solver execution statistics object.\n\nReturns\n\n(objective, iterations, constraints_violation, message, status, successful):   A tuple containing the final objective value, iteration count, primal feasibility, solver message, solver status, and success flag.\n\nExample\n\njulia> SolverInfos(nlp_solution)\n(1.23, 15, 1.0e-6, \"Ipopt/generic\", :first_order, true)\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.SolverInfos-Tuple{}","page":"Solution","title":"CTDirect.SolverInfos","text":"SolverInfos(\n\n) -> Tuple{Float64, Int64, Float64, String, Symbol, Bool}\n\n\nReturn default convergence information for an NLP solution.\n\nReturns\n\n(objective, iterations, constraints_violation, message, status, successful):   Default values representing an undefined solver state.\n\nExample\n\njulia> SolverInfos()\n(0.0, 0, 0.0, \"undefined\", :undefined, true)\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.build_OCP_solution-Tuple{Any}","page":"Solution","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(\n    docp;\n    primal,\n    dual,\n    multipliers_L,\n    multipliers_U,\n    nlp_model_backend,\n    nlp_solution\n)\n\n\nBuild an OCP functional solution from a DOCP discrete solution, given explicit primal variables, and optionally dual variables and bound multipliers.\n\nArguments\n\ndocp: The discretized optimal control problem (DOCP).\nprimal: Array of primal decision variables.\ndual: Array of dual variables (default: nothing).\nmultipliers_L: Lower bound multipliers (default: nothing).\nmultipliers_U: Upper bound multipliers (default: nothing).\nnlp_model_backend: The NLP model backend (default: ADNLPBackend()).\nnlp_solution: A solver execution statistics object.\n\nReturns\n\nsolution::CTModels.Solution: A functional OCP solution with trajectories, multipliers, and solver information.\n\nExample\n\njulia> build_OCP_solution(docp; primal=primal_vars, nlp_solution=nlp_solution)\nCTModels.Solution(...)\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.build_OCP_solution-Tuple{CTDirect.DOCP, SolverCore.AbstractExecutionStats}","page":"Solution","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(\n    docp::CTDirect.DOCP,\n    nlp_solution::SolverCore.AbstractExecutionStats\n) -> CTModels.Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#84#85\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#86#87\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#88#89\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#90#91\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#92#93\", CTModels.var\"#94#95\"}, DualModelType<:(CTModels.DualModel{PC_Dual, Vector{Float64}, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, Vector{Float64}, Vector{Float64}} where {PC_Dual<:Union{CTModels.var\"#100#101\"{CTModels.var\"#96#97\"}, CTModels.var\"#98#99\"{CTModels.var\"#96#97\"}}, SC_LB_Dual<:Union{CTModels.var\"#104#105\"{CTModels.var\"#102#103\"}, CTModels.var\"#106#107\"{CTModels.var\"#102#103\"}}, SC_UB_Dual<:Union{CTModels.var\"#110#111\"{CTModels.var\"#108#109\"}, CTModels.var\"#112#113\"{CTModels.var\"#108#109\"}}, CC_LB_Dual<:Union{CTModels.var\"#116#117\"{CTModels.var\"#114#115\"}, CTModels.var\"#118#119\"{CTModels.var\"#114#115\"}}, CC_UB_Dual<:Union{CTModels.var\"#122#123\"{CTModels.var\"#120#121\"}, CTModels.var\"#124#125\"{CTModels.var\"#120#121\"}}}), ModelType<:(CTModels.Model{<:CTModels.TimeDependence, T} where T<:CTModels.TimesModel)}\n\n\nBuild an OCP functional solution from a DOCP discrete solution given as a SolverCore.AbstractExecutionStats object.\n\nArguments\n\ndocp: The discretized optimal control problem (DOCP).\nnlp_solution: A solver execution statistics object.\n\nReturns\n\nsolution::CTModels.Solution: A functional OCP solution containing trajectories, multipliers, and solver information.\n\nExample\n\njulia> build_OCP_solution(docp, nlp_solution)\nCTModels.Solution(...)\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.is_empty-Tuple{Any}","page":"Solution","title":"CTDirect.is_empty","text":"is_empty(t) -> Any\n\n\nCheck whether a collection t is empty or not defined.\n\nArguments\n\nt: Any object that may be nothing or support length.\n\nReturns\n\n::Bool: true if t is nothing or has length zero, otherwise false.\n\nExample\n\njulia> is_empty([])\ntrue\n\njulia> is_empty([1, 2, 3])\nfalse\n\njulia> is_empty(nothing)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.parse_DOCP_solution_dual-Tuple{Any, Any}","page":"Solution","title":"CTDirect.parse_DOCP_solution_dual","text":"parse_DOCP_solution_dual(\n    docp,\n    multipliers;\n    nlp_model_backend,\n    nlp_solution\n)\n\n\nRecover OCP costates and constraint multipliers from DOCP dual variables.\n\nArguments\n\ndocp: The discretized optimal control problem (DOCP).\nmultipliers: Array of dual variables (may be nothing).\nnlp_model_backend: The NLP model backend (default: ADNLPBackend()).\nnlp_solution: A solver execution statistics object.\n\nReturns\n\n(P, path_constraints_dual, boundary_constraints_dual):  \nP: Costate trajectory.  \npath_constraints_dual: Path constraint multipliers.  \nboundary_constraints_dual: Boundary constraint multipliers.\n\nExample\n\njulia> P, path_dual, bound_dual = parse_DOCP_solution_dual(docp, duals; nlp_model_backend=nlp_model_backend, nlp_solution=nlp_solution)\n([...] , [...], [...])\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.parse_DOCP_solution_primal-Tuple{Any, Any}","page":"Solution","title":"CTDirect.parse_DOCP_solution_primal","text":"parse_DOCP_solution_primal(\n    docp,\n    solution;\n    multipliers_L,\n    multipliers_U,\n    nlp_model_backend,\n    nlp_solution\n)\n\n\nRecover OCP state, control, and optimization variables from DOCP primal variables. Bound multipliers are also parsed if available.\n\nArguments\n\ndocp: The discretized optimal control problem (DOCP).\nsolution: Array of primal decision variables.\nmultipliers_L: Lower bound multipliers.\nmultipliers_U: Upper bound multipliers.\nnlp_model_backend: The NLP model backend.\nnlp_solution: A solver execution statistics object.\n\nReturns\n\n(X, U, v, box_multipliers):  \nX: State trajectory.  \nU: Control trajectory.  \nv: Optimization variables.  \nbox_multipliers: Tuple of bound multipliers for states, controls, and variables.\n\nExample\n\njulia> X, U, v, box_mults = parse_DOCP_solution_primal(docp, primal;\n       multipliers_L=mL, multipliers_U=mU, nlp_model_backend=nlp_model_backend, nlp_solution=nlp_solution)\n([...] , [...], [...], (...))\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#Trapeze","page":"Trapeze","title":"Trapeze","text":"","category":"section"},{"location":"trapeze.html#Index","page":"Trapeze","title":"Index","text":"Pages   = [\"trapeze.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"section"},{"location":"trapeze.html#Documentation","page":"Trapeze","title":"Documentation","text":"","category":"section"},{"location":"trapeze.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"Trapeze","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"Trapeze","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.runningCost-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Any, Any}","page":"Trapeze","title":"CTDirect.runningCost","text":"runningCost(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    xu,\n    v,\n    time_grid\n) -> Any\n\n\nCompute the running cost\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Vararg{Any, 6}}","page":"Trapeze","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Any, Any}","page":"Trapeze","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"}]
}
