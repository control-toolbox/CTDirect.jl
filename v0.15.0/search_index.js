var documenterSearchIndex = {"docs":
[{"location":"docp.html#DOCP","page":"DOCP","title":"DOCP","text":"","category":"section"},{"location":"docp.html#Index","page":"DOCP","title":"Index","text":"","category":"section"},{"location":"docp.html","page":"DOCP","title":"DOCP","text":"Pages   = [\"docp.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"docp.html#Documentation","page":"DOCP","title":"Documentation","text":"","category":"section"},{"location":"docp.html#CTDirect.DOCP","page":"DOCP","title":"CTDirect.DOCP","text":"Struct for discretized optimal control problem DOCP\n\nContains:\n\na copy of the original OCP\nthe discretized DOCP as a NLP problem\ndata required to link the OCP with the discretized DOCP\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCPFlags","page":"DOCP","title":"CTDirect.DOCPFlags","text":"Internal struct for DOCP boolean flags\n\nfreet0: OCP has free initial time\nfreetf: OCP has free final time\nlagrange: OCP has a lagrange cost\nmayer: OCP has a mayer cost\nlagrangetomayer: convert lagrange cost to mayer form\nmax: OCP is a maximization problem\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCPbounds","page":"DOCP","title":"CTDirect.DOCPbounds","text":"Internal struct for DOCP bounds\n\nvar_l: lower bounds for the NLP variables\nvar_u: upper bounds for the NLP variables\ncon_l: lower bounds for the NLP constraints\ncon_u: upper bounds for the NLP constraints\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCPdims","page":"DOCP","title":"CTDirect.DOCPdims","text":"Internal struct for DOCP dimensions\n\nNLP_x: state dimension including additional component for reformulated lagrange cost\nNLP_u: control dimension\nNLP_v: variable dimension\nOCP_x: state dimension for the original OCP\npath_cons: path constraints dimension\nboundary_cons: boundary constraints dimension\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCPtime","page":"DOCP","title":"CTDirect.DOCPtime","text":"Internal struct for DOCP time grid\n\nsteps: number of time steps\nnormalized_grid: time grid rescaled to [0,1]\nfixed_grid: fixed time grid [t0,tf]\n\n\n\n\n\n","category":"type"},{"location":"docp.html#CTDirect.DOCP_constraints!-Tuple{Any, Any, CTDirect.DOCP}","page":"DOCP","title":"CTDirect.DOCP_constraints!","text":"DOCP_constraints!(c, xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the constraints C for the DOCP problem (modeled as LB <= C(X) <= UB).\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.DOCP_initial_guess","page":"DOCP","title":"CTDirect.DOCP_initial_guess","text":"DOCP_initial_guess(docp::CTDirect.DOCP) -> Vector{Float64}\nDOCP_initial_guess(\n    docp::CTDirect.DOCP,\n    init::CTModels.Init\n) -> Vector{Float64}\n\n\nBuild initial guess for discretized problem\n\n\n\n\n\n","category":"function"},{"location":"docp.html#CTDirect.DOCP_objective-Tuple{Any, CTDirect.DOCP}","page":"DOCP","title":"CTDirect.DOCP_objective","text":"DOCP_objective(xu, docp::CTDirect.DOCP) -> Any\n\n\nCompute the objective for the DOCP problem.\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.build_bounds-Tuple{Any, Any, Any}","page":"DOCP","title":"CTDirect.build_bounds","text":"build_bounds(\n    dim_var,\n    dim_box,\n    box_triplet\n) -> Tuple{Any, Any}\n\n\nBuild full, ordered sets of bounds for state, control or optimization variables\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.constraints_bounds!-Tuple{CTDirect.DOCP}","page":"DOCP","title":"CTDirect.constraints_bounds!","text":"constraints_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP nonlinear constraints.\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.get_time_grid-Tuple{Any, CTDirect.DOCP}","page":"DOCP","title":"CTDirect.get_time_grid","text":"get_time_grid(xu, docp::CTDirect.DOCP) -> Any\n\n\nReturn time grid for variable time problems (times are then dependent on NLP variables)\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.is_solvable-Tuple{Any}","page":"DOCP","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nCheck if an OCP is solvable by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.setPointConstraints!-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"DOCP","title":"CTDirect.setPointConstraints!","text":"setPointConstraints!(docp::CTDirect.DOCP, c, xu, v) -> Any\n\n\nSet the boundary and variable constraints\n\n\n\n\n\n","category":"method"},{"location":"docp.html#CTDirect.variables_bounds!-Tuple{CTDirect.DOCP}","page":"DOCP","title":"CTDirect.variables_bounds!","text":"variables_bounds!(\n    docp::CTDirect.DOCP\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\n\nBuild upper and lower bounds vectors for the DOCP variable box constraints.\n\n\n\n\n\n","category":"method"},{"location":"docp.html","page":"DOCP","title":"DOCP","text":"","category":"page"},{"location":"solve.html#Solve","page":"Solve","title":"Solve","text":"","category":"section"},{"location":"solve.html#Index","page":"Solve","title":"Index","text":"","category":"section"},{"location":"solve.html","page":"Solve","title":"Solve","text":"Pages   = [\"solve.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"solve.html#Documentation","page":"Solve","title":"Documentation","text":"","category":"section"},{"location":"solve.html#CTDirect.available_methods-Tuple{}","page":"Solve","title":"CTDirect.available_methods","text":"available_methods() -> NTuple{6, Tuple{Symbol, Symbol}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.direct_transcription-Tuple{CTModels.Model, Vararg{Any}}","page":"Solve","title":"CTDirect.direct_transcription","text":"direct_transcription(\n    ocp::CTModels.Model,\n    description...;\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    kwargs...\n)\n\n\nDiscretize an optimal control problem into a nonlinear optimization problem.\n\nArguments\n\nocp: optimal control problem as defined in CTModels\n[description]: set the NLP model ([:adnlp] or exa) and / or solver ([:ipopt], :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :euler, :euler_implicit, :midpoint, gauss_legendre_2, gauss_legendre_3)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values as named tuple or existing solution)\n\nOther kewwords arguments are passed down to the NLP modeler\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.parse_description-Tuple{Any}","page":"Solve","title":"CTDirect.parse_description","text":"parse_description(\n    description\n) -> Tuple{Union{CTDirect.IpoptBackend, CTDirect.KnitroBackend, CTDirect.MadNLPBackend}, Union{CTDirect.ADNLPBackend, CTDirect.ExaBackend}}\n\n\nParse problem description to retrieve NLP model and solver choice\n\nNLP solver: ipopt, madnlp or knitro \nNLP model: :adnlp or :exa\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.set_initial_guess-Tuple{CTDirect.DOCP, Any}","page":"Solve","title":"CTDirect.set_initial_guess","text":"set_initial_guess(docp::CTDirect.DOCP, init) -> Any\n\n\nSet initial guess in the DOCP\n\n\n\n\n\n","category":"method"},{"location":"solve.html#CTDirect.solve-Tuple{CTModels.Model, Vararg{Symbol}}","page":"Solve","title":"CTDirect.solve","text":"solve(\n    ocp::CTModels.Model,\n    description::Symbol...;\n    display,\n    grid_size,\n    disc_method,\n    time_grid,\n    init,\n    adnlp_backend,\n    exa_backend,\n    kwargs...\n)\n\n\nSolve an OCP with a direct method\n\nArguments\n\nocp: optimal control problem as defined in CTModels\n[description]: set the NLP model ([:adnlp] or exa) and / or solver ([:ipopt], :madnlp or :knitro)\n\nKeyword arguments (optional)\n\ndisplay: ([true], false) will disable output if set to false\ngrid_size: number of time steps for the discretized problem ([250])\ndisc_method: discretization method ([:trapeze], :midpoint, gauss_legendre_2)\ntime_grid: explicit time grid (can be non uniform)\ninit: info for the starting guess (values or existing solution)\n\nOther keywords are passed down to the NLP modeler and solver.\n\nResult: a continuous solution of the original OCP, with main features\n\nobjective(sol): value of the objective\nstate(sol), control(sol): functions for state and control variables (trajectory)\nvariable(sol): optimization variables if any (e.g. free final time)\nsuccessful(sol): boolean indicating successful convergence of the NLP solver\nstatus(sol): symbol for the return code of the NLP solver\nmessage(sol): string with specific info from the NLP solver, if any\nconstraints_violation(sol): primal feasibility at the solution\niterations(sol): number of iterations \n\n\n\n\n\n","category":"method"},{"location":"solve.html","page":"Solve","title":"Solve","text":"","category":"page"},{"location":"default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"default.html#Index","page":"Default","title":"Index","text":"","category":"section"},{"location":"default.html","page":"Default","title":"Default","text":"Pages   = [\"default.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"default.html#Documentation","page":"Default","title":"Documentation","text":"","category":"section"},{"location":"default.html#CTDirect.__adnlp_backend-Tuple{}","page":"Default","title":"CTDirect.__adnlp_backend","text":"__adnlp_backend() -> Symbol\n\n\nDefault backend for ADNLPModels: :optimized\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__disc_method-Tuple{}","page":"Default","title":"CTDirect.__disc_method","text":"__disc_method() -> Symbol\n\n\nDefault discretization method: trapeze.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__display-Tuple{}","page":"Default","title":"CTDirect.__display","text":"__display() -> Bool\n\n\nDefault display toggle: true\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__exa_backend-Tuple{}","page":"Default","title":"CTDirect.__exa_backend","text":"__exa_backend()\n\n\nDefault backend for ExaModels: nothing\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__grid_size-Tuple{}","page":"Default","title":"CTDirect.__grid_size","text":"__grid_size() -> Int64\n\n\nDefault grid size: 250.\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__ipopt_linear_solver-Tuple{}","page":"Default","title":"CTDirect.__ipopt_linear_solver","text":"__ipopt_linear_solver() -> String\n\n\nDefault value for Ipopt linear solver: mumps\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__ipopt_mu_strategy-Tuple{}","page":"Default","title":"CTDirect.__ipopt_mu_strategy","text":"__ipopt_mu_strategy() -> String\n\n\nDefault value for Ipopt mu strategy: adaptive\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__ipopt_print_level-Tuple{}","page":"Default","title":"CTDirect.__ipopt_print_level","text":"__ipopt_print_level() -> Int64\n\n\nDefault value for Ipopt print level: 5\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__knitro_print_level-Tuple{}","page":"Default","title":"CTDirect.__knitro_print_level","text":"__knitro_print_level() -> Int64\n\n\nDefault value for Knitro print level: 3\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__madnlp_linear_solver-Tuple{}","page":"Default","title":"CTDirect.__madnlp_linear_solver","text":"__madnlp_linear_solver() -> String\n\n\nDefault value for MadNLP linear solver: umfpack\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__max_iterations-Tuple{}","page":"Default","title":"CTDirect.__max_iterations","text":"__max_iterations() -> Int64\n\n\nDefault maximum of iterations: 1000\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__ocp_init-Tuple{}","page":"Default","title":"CTDirect.__ocp_init","text":"__ocp_init()\n\n\nDefault initial guess: nothing (corresponds to 0.1 for all variables)\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__time_grid-Tuple{}","page":"Default","title":"CTDirect.__time_grid","text":"__time_grid()\n\n\nDefault (non uniform) time grid: nothing\n\n\n\n\n\n","category":"method"},{"location":"default.html#CTDirect.__tolerance-Tuple{}","page":"Default","title":"CTDirect.__tolerance","text":"__tolerance() -> Float64\n\n\nDefault tolerance: 1e-8\n\n\n\n\n\n","category":"method"},{"location":"default.html","page":"Default","title":"Default","text":"","category":"page"},{"location":"ctdirectext_knitro.html#CTDirectExtKnitro","page":"CTDirectExtKnitro","title":"CTDirectExtKnitro","text":"","category":"section"},{"location":"ctdirectext_knitro.html#Index","page":"CTDirectExtKnitro","title":"Index","text":"","category":"section"},{"location":"ctdirectext_knitro.html","page":"CTDirectExtKnitro","title":"CTDirectExtKnitro","text":"Pages   = [\"ctdirectext_knitro.md\"]\nModules = [CTDirect, CTDirectExtKnitro]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctdirectext_knitro.html#Documentation","page":"CTDirectExtKnitro","title":"Documentation","text":"","category":"section"},{"location":"ctdirectext_knitro.html#CTDirect.solve_docp-Tuple{CTDirect.KnitroBackend, CTDirect.DOCP}","page":"CTDirectExtKnitro","title":"CTDirect.solve_docp","text":"solve_docp(\n    solver_backend::CTDirect.KnitroBackend,\n    docp::CTDirect.DOCP;\n    display,\n    max_iter,\n    tol,\n    print_level,\n    kwargs...\n)\n\n\nSolve a discretized optimal control problem with Ipopt\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_knitro.html","page":"CTDirectExtKnitro","title":"CTDirectExtKnitro","text":"","category":"page"},{"location":"common.html#Common","page":"Common","title":"Common","text":"","category":"section"},{"location":"common.html#Index","page":"Common","title":"Index","text":"","category":"section"},{"location":"common.html","page":"Common","title":"Common","text":"Pages   = [\"common.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"common.html#Documentation","page":"Common","title":"Documentation","text":"","category":"section"},{"location":"common.html#CTDirect.DOCP_Hessian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"Common","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.DOCP_Jacobian_pattern-Union{Tuple{CTDirect.DOCP{D}}, Tuple{D}} where D<:CTDirect.Discretization","page":"Common","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{D<:CTDirect.Discretization}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.add_nonzero_block!-NTuple{5, Any}","page":"Common","title":"CTDirect.add_nonzero_block!","text":"add_nonzero_block!(M, i_start, i_end, j_start, j_end; sym)\n\n\nAdd block of nonzeros elements to a sparsity pattern  Format: boolean matrix (M) or index vectors (Is, Js)  Includes a more compact method for single element case Option to add the symmetric block also (eg for Hessian) Note: independent from discretization scheme\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1), with convention u(tf) = U_N Vector output\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_OCP_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.get_OCP_state_at_time_step","text":"get_OCP_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variables at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1 Vector output\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_OCP_variable-Tuple{Any, CTDirect.DOCP}","page":"Common","title":"CTDirect.get_OCP_variable","text":"get_OCP_variable(xu, docp::CTDirect.DOCP) -> Any\n\n\nRetrieve optimization variables from the NLP variables. Convention: stored at the end, hence not dependent on the discretization method Vector output\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_lagrange_state_at_time_step-Tuple{Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.get_lagrange_state_at_time_step","text":"get_lagrange_state_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nRetrieve state variable for lagrange cost at given time step from the NLP variables. Convention: 1 <= i <= dimNLPsteps+1   (no check for actual lagrange cost presence !)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.get_stagevars_at_time_step-Tuple{Any, CTDirect.DOCP, Any, Any}","page":"Common","title":"CTDirect.get_stagevars_at_time_step","text":"get_stagevars_at_time_step(\n    xu,\n    docp::CTDirect.DOCP,\n    i,\n    j\n) -> Any\n\n\nRetrieve stage variables at given time step/stage from the NLP variables. Convention: 1 <= i <= dimNLPsteps(+1),\t1 <= j <= s Vector output Note that passing correct indices is up to the caller, no checks are made here.\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP, Any, Any, Any}","page":"Common","title":"CTDirect.setWorkArray","text":"setWorkArray(docp::CTDirect.DOCP, xu, time_grid, v) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.set_control_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.set_control_at_time_step!","text":"set_control_at_time_step!(\n    xu,\n    u_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for control variables at given time step Convention: 1 <= i <= dimNLPsteps(+1)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.set_optim_variable!-Tuple{Any, Any, Any}","page":"Common","title":"CTDirect.set_optim_variable!","text":"set_optim_variable!(xu, v_init, docp) -> Any\n\n\nSet optimization variables in the NLP variables (for initial guess)\n\n\n\n\n\n","category":"method"},{"location":"common.html#CTDirect.set_state_at_time_step!-Tuple{Any, Any, CTDirect.DOCP, Any}","page":"Common","title":"CTDirect.set_state_at_time_step!","text":"set_state_at_time_step!(\n    xu,\n    x_init,\n    docp::CTDirect.DOCP,\n    i\n) -> Any\n\n\nSet initial guess for state variables at given time step Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"common.html","page":"Common","title":"Common","text":"","category":"page"},{"location":"irk.html#IRK","page":"IRK","title":"IRK","text":"","category":"section"},{"location":"irk.html#Index","page":"IRK","title":"Index","text":"","category":"section"},{"location":"irk.html","page":"IRK","title":"IRK","text":"Pages   = [\"irk.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"irk.html#Documentation","page":"IRK","title":"Documentation","text":"","category":"section"},{"location":"irk.html#CTDirect.Gauss_Legendre_1","page":"IRK","title":"CTDirect.Gauss_Legendre_1","text":"Implicit Midpoint discretization, formulated as a generic IRK (ie Gauss Legendre 1) For testing purpose only, use :midpoint instead (cf midpoint.jl) !\n\n\n\n\n\n","category":"type"},{"location":"irk.html#CTDirect.Gauss_Legendre_2","page":"IRK","title":"CTDirect.Gauss_Legendre_2","text":"Gauss Legendre 2 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"irk.html#CTDirect.Gauss_Legendre_3","page":"IRK","title":"CTDirect.Gauss_Legendre_3","text":"Gauss Legendre 3 discretization, formulated as a generic IRK\n\n\n\n\n\n","category":"type"},{"location":"irk.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"IRK","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}}","page":"IRK","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.IRK_dims-NTuple{7, Any}","page":"IRK","title":"CTDirect.IRK_dims","text":"IRK_dims(\n    dim_NLP_steps,\n    dim_NLP_x,\n    dim_NLP_u,\n    dim_NLP_v,\n    dim_path_cons,\n    dim_boundary_cons,\n    stage\n) -> NTuple{5, Any}\n\n\nReturn the dimension of the NLP variables and constraints for a generic IRK discretizion, with the control taken constant per step (ie not distinct controls at time stages)\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Vararg{Any, 6}}","page":"IRK","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps (+1)\n\n\n\n\n\n","category":"method"},{"location":"irk.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{<:CTDirect.GenericIRK}, Any, Any, Any}","page":"IRK","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{<:CTDirect.GenericIRK},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"irk.html","page":"IRK","title":"IRK","text":"","category":"page"},{"location":"ctdirectext_madnlp.html#CTDirectExtMadNLP","page":"CTDirectExtMadNLP","title":"CTDirectExtMadNLP","text":"","category":"section"},{"location":"ctdirectext_madnlp.html#Index","page":"CTDirectExtMadNLP","title":"Index","text":"","category":"section"},{"location":"ctdirectext_madnlp.html","page":"CTDirectExtMadNLP","title":"CTDirectExtMadNLP","text":"Pages   = [\"ctdirectext_madnlp.md\"]\nModules = [CTDirect, CTDirectExtMadNLP]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctdirectext_madnlp.html#Documentation","page":"CTDirectExtMadNLP","title":"Documentation","text":"","category":"section"},{"location":"ctdirectext_madnlp.html#CTDirect.solve_docp-Tuple{CTDirect.MadNLPBackend, CTDirect.DOCP}","page":"CTDirectExtMadNLP","title":"CTDirect.solve_docp","text":"solve_docp(\n    solver_backend::CTDirect.MadNLPBackend,\n    docp::CTDirect.DOCP;\n    display,\n    max_iter,\n    tol,\n    linear_solver,\n    kwargs...\n) -> MadNLP.MadNLPExecutionStats\n\n\nSolve a discretized optimal control problem DOCP\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_madnlp.html","page":"CTDirectExtMadNLP","title":"CTDirectExtMadNLP","text":"","category":"page"},{"location":"ctdirectext_ipopt.html#CTDirectExtIpopt","page":"CTDirectExtIpopt","title":"CTDirectExtIpopt","text":"","category":"section"},{"location":"ctdirectext_ipopt.html#Index","page":"CTDirectExtIpopt","title":"Index","text":"","category":"section"},{"location":"ctdirectext_ipopt.html","page":"CTDirectExtIpopt","title":"CTDirectExtIpopt","text":"Pages   = [\"ctdirectext_ipopt.md\"]\nModules = [CTDirect, CTDirectExtIpopt]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctdirectext_ipopt.html#Documentation","page":"CTDirectExtIpopt","title":"Documentation","text":"","category":"section"},{"location":"ctdirectext_ipopt.html#CTDirect.solve_docp-Tuple{CTDirect.IpoptBackend, CTDirect.DOCP}","page":"CTDirectExtIpopt","title":"CTDirect.solve_docp","text":"solve_docp(\n    solver_backend::CTDirect.IpoptBackend,\n    docp::CTDirect.DOCP;\n    display,\n    max_iter,\n    tol,\n    print_level,\n    mu_strategy,\n    linear_solver,\n    kwargs...\n) -> SolverCore.GenericExecutionStats\n\n\nSolve a discretized optimal control problem (Ipopt version).\n\n\n\n\n\n","category":"method"},{"location":"ctdirectext_ipopt.html","page":"CTDirectExtIpopt","title":"CTDirectExtIpopt","text":"","category":"page"},{"location":"midpoint.html#Midpoint","page":"Midpoint","title":"Midpoint","text":"","category":"section"},{"location":"midpoint.html#Index","page":"Midpoint","title":"Index","text":"","category":"section"},{"location":"midpoint.html","page":"Midpoint","title":"Midpoint","text":"Pages   = [\"midpoint.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"midpoint.html#Documentation","page":"Midpoint","title":"Documentation","text":"","category":"section"},{"location":"midpoint.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"Midpoint","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Midpoint}}","page":"Midpoint","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Midpoint}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Vararg{Any, 6}}","page":"Midpoint","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Midpoint}, Any, Any, Any}","page":"Midpoint","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Midpoint},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"midpoint.html","page":"Midpoint","title":"Midpoint","text":"","category":"page"},{"location":"solution.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"solution.html#Index","page":"Solution","title":"Index","text":"","category":"section"},{"location":"solution.html","page":"Solution","title":"Solution","text":"Pages   = [\"solution.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"solution.html#Documentation","page":"Solution","title":"Documentation","text":"","category":"section"},{"location":"solution.html#CTDirect.SolverInfos-Tuple{}","page":"Solution","title":"CTDirect.SolverInfos","text":"SolverInfos() -> Tuple{Int64, Float64, String, Symbol, Bool}\n\n\nRetrieve convergence information from NLP solution\n\niterations [Integer]: number of iterations\nconstraints_violations [Real]: primal feasibility\nstatus [Symbol]: termination status from the NLP solver\nsuccessful [Boolean]: indicates successful convergence (first order)\nmessage [String]: optional solver dependent message\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.build_OCP_solution-Tuple{Any, Any}","page":"Solution","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(\n    docp,\n    docp_solution\n) -> CTModels.Solution{TimeGridModelType, TimesModelType, StateModelType, ControlModelType, VariableModelType, CostateModelType, Float64, DualModelType, CTModels.SolverInfos{Dict{Symbol, Any}}, ModelType} where {TimeGridModelType<:CTModels.TimeGridModel, TimesModelType<:CTModels.TimesModel, StateModelType<:Union{CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#114#136\", CTModels.StateModelSolution{TS} where TS<:CTModels.var\"#115#137\"}, ControlModelType<:Union{CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#116#138\", CTModels.ControlModelSolution{TS} where TS<:CTModels.var\"#117#139\"}, VariableModelType<:Union{CTModels.VariableModelSolution{Vector{Float64}}, CTModels.VariableModelSolution{Float64}}, CostateModelType<:Union{CTModels.var\"#118#140\", CTModels.var\"#119#141\"}, DualModelType<:(CTModels.DualModel{PC_Dual, BC_Dual, SC_LB_Dual, SC_UB_Dual, CC_LB_Dual, CC_UB_Dual, VC_LB_Dual, VC_UB_Dual} where {PC_Dual<:Union{Nothing, CTModels.var\"#121#143\", CTModels.var\"#122#144\"}, BC_Dual<:Union{Nothing, Vector{Float64}}, SC_LB_Dual<:Union{Nothing, CTModels.var\"#124#146\", CTModels.var\"#125#147\"}, SC_UB_Dual<:Union{Nothing, CTModels.var\"#127#149\", CTModels.var\"#128#150\"}, CC_LB_Dual<:Union{Nothing, CTModels.var\"#130#152\", CTModels.var\"#131#153\"}, CC_UB_Dual<:Union{Nothing, CTModels.var\"#133#155\", CTModels.var\"#134#156\"}, VC_LB_Dual<:Union{Nothing, Vector{Float64}}, VC_UB_Dual<:Union{Nothing, Vector{Float64}}}), ModelType<:CTModels.Model}\n\n\nBuild OCP functional solution from DOCP discrete solution  (given as a SolverCore.GenericExecutionStats)\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.build_OCP_solution-Tuple{Any}","page":"Solution","title":"CTDirect.build_OCP_solution","text":"build_OCP_solution(docp; primal, dual, mult_LB, mult_UB)\n\n\nBuild OCP functional solution from DOCP discrete solution  (given as array for primal variables, optionally dual variables and bounds multipliers)\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.parse_DOCP_solution_dual-Tuple{Any, Any}","page":"Solution","title":"CTDirect.parse_DOCP_solution_dual","text":"parse_DOCP_solution_dual(\n    docp,\n    multipliers\n) -> Tuple{Any, Any, Any}\n\n\nRecover OCP costate and constraints multipliers from DOCP dual variables.\n\n\n\n\n\n","category":"method"},{"location":"solution.html#CTDirect.parse_DOCP_solution_primal-Tuple{Any, Any}","page":"Solution","title":"CTDirect.parse_DOCP_solution_primal","text":"parse_DOCP_solution_primal(\n    docp,\n    solution;\n    mult_LB,\n    mult_UB\n) -> Tuple{Any, Any, Any, NTuple{6, Any}}\n\n\nRecover OCP state, control and optimization variables from DOCP primal variables. Bounds multipliers will be parsed as well if present.\n\n\n\n\n\n","category":"method"},{"location":"solution.html","page":"Solution","title":"Solution","text":"","category":"page"},{"location":"euler.html#Euler","page":"Euler","title":"Euler","text":"","category":"section"},{"location":"euler.html#Index","page":"Euler","title":"Index","text":"","category":"section"},{"location":"euler.html","page":"Euler","title":"Euler","text":"Pages   = [\"euler.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"euler.html#Documentation","page":"Euler","title":"Documentation","text":"","category":"section"},{"location":"euler.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Euler}}","page":"Euler","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Euler}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Euler}}","page":"Euler","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Euler}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.get_OCP_control_at_time_step-Tuple{Any, CTDirect.DOCP{CTDirect.Euler}, Any}","page":"Euler","title":"CTDirect.get_OCP_control_at_time_step","text":"get_OCP_control_at_time_step(\n    xu,\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    i\n) -> Any\n\n\nRetrieve control variables at given time step from the NLP variables. Convention: see above for explicit / implicit versions Vector output\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Euler}, Vararg{Any, 6}}","page":"Euler","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"euler.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Euler}, Any, Any, Any}","page":"Euler","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Euler},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"euler.html","page":"Euler","title":"Euler","text":"","category":"page"},{"location":"index.html#CTDirect.jl","page":"Introduction","title":"CTDirect.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To install a package from the control-toolbox ecosystem, please visit the installation page.","category":"page"},{"location":"index.html#API-Documentation","page":"Introduction","title":"API Documentation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = Main.API_PAGES\nDepth = 1","category":"page"},{"location":"index.html#Brief-Overview","page":"Introduction","title":"Brief Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An optimal control problem with fixed initial and final times, denoted (OCP), can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The so-called direct approach transforms the infinite dimensional optimal control problem (OCP) into a finite dimensional optimization problem (NLP). This is done by a discretization in time by Runge-Kutta methods applied to the state and control variables, as well as the dynamics equation. These methods are usually less precise than indirect methods based on Pontryagin’s Maximum Principle, but more robust with respect to the initialization. Also, they are more straightforward to apply, hence their wide use in industrial applications. We refer the reader to for instance[1] and [2] for more details on direct transcription methods and NLP algorithms.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1]: J. T. Betts. Practical methods for optimal control using nonlinear programming. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2001.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[2]: J. Nocedal and S.J. Wright. Numerical optimization. Springer-Verlag, New York, 1999.****","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Example of the time discretization by the trapezoidal rule:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarraylcl\nt in t_0t_f    to  t_0 ldots t_N=t_f02em\nx(cdot) u(cdot)  to  X=x_0 ldots x_N u_0 ldots u_N 1em\nhline\n\ntextstep  to  h = (t_f-t_0)N02em\ntextcriterion  to  min g(x_0 x_N) 02em\ntextdynamics   to  x_i+i = x_i + (h2) (f(t_i x_i u_i) + f(t_i+1 x_i+1 u_i+1)) 02em\ntextcontrol constraints to xi_l  le  xi(t_i u_i)   le xi_u 02em\ntextpath constraints to eta_l le eta(t_i x_i)        le eta_u 02em\ntextmixed constraints to psi_l le psi(t_i x_i u_i) le psi_u 02em\ntextlimit conditions to phi_l le phi(x_0 x_N) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We therefore obtain a nonlinear programming problem on the discretized state and control variables of the general form:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(NLP)quad left\nbeginarraylr\nmin  F(X) \nLB le C(X) le UB\nendarray\nright","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Solving the (NLP) problem is done using packages from JuliaSmoothOptimizers, with Ipopt as the default solver.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"On the input side of this package, we use a Model structure from CTModels to define the (OCP).","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The direct transcription to build the (NLP) can use discretization schemes such as trapeze (default), midpoint, or Gauss-Legendre collocations.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Related packages\nThis package is a successor to the bocop software.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"trapeze.html#Trapeze","page":"Trapeze","title":"Trapeze","text":"","category":"section"},{"location":"trapeze.html#Index","page":"Trapeze","title":"Index","text":"","category":"section"},{"location":"trapeze.html","page":"Trapeze","title":"Trapeze","text":"Pages   = [\"trapeze.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"trapeze.html#Documentation","page":"Trapeze","title":"Documentation","text":"","category":"section"},{"location":"trapeze.html#CTDirect.DOCP_Hessian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"Trapeze","title":"CTDirect.DOCP_Hessian_pattern","text":"DOCP_Hessian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Hessian of Lagrangian\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.DOCP_Jacobian_pattern-Tuple{CTDirect.DOCP{CTDirect.Trapeze}}","page":"Trapeze","title":"CTDirect.DOCP_Jacobian_pattern","text":"DOCP_Jacobian_pattern(\n    docp::CTDirect.DOCP{CTDirect.Trapeze}\n) -> SparseArrays.SparseMatrixCSC{Bool, Int64}\n\n\nBuild sparsity pattern for Jacobian of constraints\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.setStepConstraints!-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Vararg{Any, 6}}","page":"Trapeze","title":"CTDirect.setStepConstraints!","text":"setStepConstraints!(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    c,\n    xu,\n    v,\n    time_grid,\n    i,\n    work\n) -> Any\n\n\nSet the constraints corresponding to the state equation Convention: 1 <= i <= dimNLPsteps+1\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html#CTDirect.setWorkArray-Tuple{CTDirect.DOCP{CTDirect.Trapeze}, Any, Any, Any}","page":"Trapeze","title":"CTDirect.setWorkArray","text":"setWorkArray(\n    docp::CTDirect.DOCP{CTDirect.Trapeze},\n    xu,\n    time_grid,\n    v\n) -> Any\n\n\nSet work array for all dynamics and lagrange cost evaluations\n\n\n\n\n\n","category":"method"},{"location":"trapeze.html","page":"Trapeze","title":"Trapeze","text":"","category":"page"}]
}
